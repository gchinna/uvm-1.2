<html><head><title>uvm_object</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script language=JavaScript src="../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CClass"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="uvm_object" href="../../src/base/uvm_object.svh">uvm_object</a></h1><div class=CBody><p>The uvm_object class is the base class for all UVM data and hierarchical classes.&nbsp; Its primary role is to define a set of methods for such common operations as <a href="#uvm_object.create" class=LMethod id=link48 onMouseOver="ShowTip(event, 'tt14', 'link48')" onMouseOut="HideTip('tt14')">create</a>, <a href="#uvm_object.copy" class=LMethod id=link49 onMouseOver="ShowTip(event, 'tt23', 'link49')" onMouseOut="HideTip('tt23')">copy</a>, <a href="#uvm_object.compare" class=LMethod id=link50 onMouseOver="ShowTip(event, 'tt25', 'link50')" onMouseOut="HideTip('tt25')">compare</a>, <a href="#uvm_object.print" class=LMethod id=link51 onMouseOver="ShowTip(event, 'tt16', 'link51')" onMouseOut="HideTip('tt16')">print</a>, and <a href="#uvm_object.record" class=LMethod id=link52 onMouseOver="ShowTip(event, 'tt21', 'link52')" onMouseOut="HideTip('tt21')">record</a>.&nbsp; Classes deriving from uvm_object must implement the pure virtual methods such as <a href="#uvm_object.create" class=LMethod id=link53 onMouseOver="ShowTip(event, 'tt14', 'link53')" onMouseOut="HideTip('tt14')">create</a> and <a href="#uvm_object.get_type_name" class=LMethod id=link54 onMouseOver="ShowTip(event, 'tt13', 'link54')" onMouseOut="HideTip('tt13')">get_type_name</a>.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#uvm_object" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">uvm_object</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>The uvm_object class is the base class for all UVM data and hierarchical classes. </td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry><a href="uvm_misc-svh.html#uvm_void" class=LClass id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">uvm_void</a></div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>uvm_object</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_object extends uvm_void
  </td></tr></table></blockquote></td></tr>

  <!-- index=1 -->

<tr class="SMethod SIndent1 SMarked"><td class=SEntry><a href="#uvm_object.new" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">new</a></td><td class=SDescription>Creates a new uvm_object with the given instance <i>name</i>. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Seeding" >Seeding</a></td><td class=SDescription></td></tr>
  <!-- index=3 -->

<tr class="SVariable SIndent2"><td class=SEntry><a href="#uvm_object.use_uvm_seeding" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">use_uvm_seeding</a></td><td class=SDescription>This bit enables or disables the UVM seeding mechanism. </td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.reseed" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">reseed</a></td><td class=SDescription>Calls <i>srandom</i> on the object to reseed the object using the UVM seeding mechanism, which sets the seed based on type name and instance name instead of based on instance position in a thread.</td></tr>
  <!-- index=5 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Identification" >Identification</a></td><td class=SDescription></td></tr>
  <!-- index=6 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.set_name" id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">set_name</a></td><td class=SDescription>Sets the instance name of this object, overwriting any previously given name.</td></tr>
  <!-- index=7 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.get_name" id=link7 onMouseOver="ShowTip(event, 'tt7', 'link7')" onMouseOut="HideTip('tt7')">get_name</a></td><td class=SDescription>Returns the name of the object, as provided by the <i>name</i> argument in the <a href="#uvm_object.new" class=LMethod id=link8 onMouseOver="ShowTip(event, 'tt3', 'link8')" onMouseOut="HideTip('tt3')">new</a> constructor or <a href="#uvm_object.set_name" class=LMethod id=link9 onMouseOver="ShowTip(event, 'tt6', 'link9')" onMouseOut="HideTip('tt6')">set_name</a> method.</td></tr>
  <!-- index=8 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.get_full_name" id=link10 onMouseOver="ShowTip(event, 'tt8', 'link10')" onMouseOut="HideTip('tt8')">get_full_name</a></td><td class=SDescription>Returns the full hierarchical name of this object. </td></tr>
  <!-- index=9 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.get_inst_id" id=link11 onMouseOver="ShowTip(event, 'tt9', 'link11')" onMouseOut="HideTip('tt9')">get_inst_id</a></td><td class=SDescription>Returns the object&rsquo;s unique, numeric instance identifier.</td></tr>
  <!-- index=10 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.get_inst_count" id=link12 onMouseOver="ShowTip(event, 'tt10', 'link12')" onMouseOut="HideTip('tt10')">get_inst_count</a></td><td class=SDescription>Returns the current value of the instance counter, which represents the total number of uvm_object-based objects that have been allocated in simulation. </td></tr>
  <!-- index=11 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.get_type" id=link13 onMouseOver="ShowTip(event, 'tt11', 'link13')" onMouseOut="HideTip('tt11')">get_type</a></td><td class=SDescription>Returns the type-proxy (wrapper) for this object. </td></tr>
  <!-- index=12 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.get_object_type" id=link14 onMouseOver="ShowTip(event, 'tt12', 'link14')" onMouseOut="HideTip('tt12')">get_object_type</a></td><td class=SDescription>Returns the type-proxy (wrapper) for this object. </td></tr>
  <!-- index=13 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.get_type_name" id=link15 onMouseOver="ShowTip(event, 'tt13', 'link15')" onMouseOut="HideTip('tt13')">get_type_name</a></td><td class=SDescription>This function returns the type name of the object, which is typically the type identifier enclosed in quotes. </td></tr>
  <!-- index=14 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Creation" >Creation</a></td><td class=SDescription></td></tr>
  <!-- index=15 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.create" id=link16 onMouseOver="ShowTip(event, 'tt14', 'link16')" onMouseOut="HideTip('tt14')">create</a></td><td class=SDescription>The <i>create</i> method allocates a new object of the same type as this object and returns it via a base uvm_object handle. </td></tr>
  <!-- index=16 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.clone" id=link17 onMouseOver="ShowTip(event, 'tt15', 'link17')" onMouseOut="HideTip('tt15')">clone</a></td><td class=SDescription>The <i>clone</i> method creates and returns an exact copy of this object.</td></tr>
  <!-- index=17 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Printing" >Printing</a></td><td class=SDescription></td></tr>
  <!-- index=18 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.print" id=link18 onMouseOver="ShowTip(event, 'tt16', 'link18')" onMouseOut="HideTip('tt16')">print</a></td><td class=SDescription>The <i>print</i> method deep-prints this object&rsquo;s properties in a format and manner governed by the given <i>printer</i> argument; if the <i>printer</i> argument is not provided, the global <a href="uvm_object_globals-svh.html#uvm_default_printer" class=LVariable id=link19 onMouseOver="ShowTip(event, 'tt17', 'link19')" onMouseOut="HideTip('tt17')">uvm_default_printer</a> is used. </td></tr>
  <!-- index=19 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.sprint" id=link20 onMouseOver="ShowTip(event, 'tt18', 'link20')" onMouseOut="HideTip('tt18')">sprint</a></td><td class=SDescription>The <i>sprint</i> method works just like the <a href="#uvm_object.print" class=LMethod id=link21 onMouseOver="ShowTip(event, 'tt16', 'link21')" onMouseOut="HideTip('tt16')">print</a> method, except the output is returned in a string rather than displayed.</td></tr>
  <!-- index=20 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.do_print" id=link22 onMouseOver="ShowTip(event, 'tt19', 'link22')" onMouseOut="HideTip('tt19')">do_print</a></td><td class=SDescription>The <i>do_print</i> method is the user-definable hook called by <a href="#uvm_object.print" class=LMethod id=link23 onMouseOver="ShowTip(event, 'tt16', 'link23')" onMouseOut="HideTip('tt16')">print</a> and <a href="#uvm_object.sprint" class=LMethod id=link24 onMouseOver="ShowTip(event, 'tt18', 'link24')" onMouseOut="HideTip('tt18')">sprint</a> that allows users to customize what gets printed or sprinted beyond the field information provided by the `uvm_field_* macros, <a href="../macros/uvm_object_defines-svh.html#Utility_and_Field_Macros_for_Components_and_Objects" class=LSection >Utility and Field Macros for Components and Objects</a>.</td></tr>
  <!-- index=21 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.convert2string" id=link25 onMouseOver="ShowTip(event, 'tt20', 'link25')" onMouseOut="HideTip('tt20')">convert2string</a></td><td class=SDescription>This virtual function is a user-definable hook, called directly by the user, that allows users to provide object information in the form of a string. </td></tr>
  <!-- index=22 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Recording" >Recording</a></td><td class=SDescription></td></tr>
  <!-- index=23 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.record" id=link26 onMouseOver="ShowTip(event, 'tt21', 'link26')" onMouseOut="HideTip('tt21')">record</a></td><td class=SDescription>The <i>record</i> method deep-records this object&rsquo;s properties according to an optional <i>recorder</i> policy. </td></tr>
  <!-- index=24 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.do_record" id=link27 onMouseOver="ShowTip(event, 'tt22', 'link27')" onMouseOut="HideTip('tt22')">do_record</a></td><td class=SDescription>The <i>do_record</i> method is the user-definable hook called by the <a href="#uvm_object.record" class=LMethod id=link28 onMouseOver="ShowTip(event, 'tt21', 'link28')" onMouseOut="HideTip('tt21')">record</a> method. </td></tr>
  <!-- index=25 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Copying" >Copying</a></td><td class=SDescription></td></tr>
  <!-- index=26 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.copy" id=link29 onMouseOver="ShowTip(event, 'tt23', 'link29')" onMouseOut="HideTip('tt23')">copy</a></td><td class=SDescription>The copy makes this object a copy of the specified object.</td></tr>
  <!-- index=27 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.do_copy" id=link30 onMouseOver="ShowTip(event, 'tt24', 'link30')" onMouseOut="HideTip('tt24')">do_copy</a></td><td class=SDescription>The <i>do_copy</i> method is the user-definable hook called by the <a href="#uvm_object.copy" class=LMethod id=link31 onMouseOver="ShowTip(event, 'tt23', 'link31')" onMouseOut="HideTip('tt23')">copy</a> method. </td></tr>
  <!-- index=28 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Comparing" >Comparing</a></td><td class=SDescription></td></tr>
  <!-- index=29 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.compare" id=link32 onMouseOver="ShowTip(event, 'tt25', 'link32')" onMouseOut="HideTip('tt25')">compare</a></td><td class=SDescription>Deep compares members of this data object with those of the object provided in the <i>rhs</i> (right-hand side) argument, returning 1 on a match, 0 otherwise.</td></tr>
  <!-- index=30 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.do_compare" id=link33 onMouseOver="ShowTip(event, 'tt26', 'link33')" onMouseOut="HideTip('tt26')">do_compare</a></td><td class=SDescription>The <i>do_compare</i> method is the user-definable hook called by the <a href="#uvm_object.compare" class=LMethod id=link34 onMouseOver="ShowTip(event, 'tt25', 'link34')" onMouseOut="HideTip('tt25')">compare</a> method. </td></tr>
  <!-- index=31 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Packing" >Packing</a></td><td class=SDescription></td></tr>
  <!-- index=32 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.pack" id=link35 onMouseOver="ShowTip(event, 'tt27', 'link35')" onMouseOut="HideTip('tt27')">pack</a></td><td class=SDescription></td></tr>
  <!-- index=33 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.pack_bytes" id=link36 onMouseOver="ShowTip(event, 'tt28', 'link36')" onMouseOut="HideTip('tt28')">pack_bytes</a></td><td class=SDescription></td></tr>
  <!-- index=34 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.pack_ints" id=link37 onMouseOver="ShowTip(event, 'tt29', 'link37')" onMouseOut="HideTip('tt29')">pack_ints</a></td><td class=SDescription>The pack methods bitwise-concatenate this object&rsquo;s properties into an array of bits, bytes, or ints. </td></tr>
  <!-- index=35 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.do_pack" id=link38 onMouseOver="ShowTip(event, 'tt30', 'link38')" onMouseOut="HideTip('tt30')">do_pack</a></td><td class=SDescription>The <i>do_pack</i> method is the user-definable hook called by the <a href="#uvm_object.pack" class=LMethod id=link39 onMouseOver="ShowTip(event, 'tt27', 'link39')" onMouseOut="HideTip('tt27')">pack</a> methods. </td></tr>
  <!-- index=36 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Unpacking" >Unpacking</a></td><td class=SDescription></td></tr>
  <!-- index=37 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.unpack" id=link40 onMouseOver="ShowTip(event, 'tt31', 'link40')" onMouseOut="HideTip('tt31')">unpack</a></td><td class=SDescription></td></tr>
  <!-- index=38 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.unpack_bytes" id=link41 onMouseOver="ShowTip(event, 'tt32', 'link41')" onMouseOut="HideTip('tt32')">unpack_bytes</a></td><td class=SDescription></td></tr>
  <!-- index=39 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.unpack_ints" id=link42 onMouseOver="ShowTip(event, 'tt33', 'link42')" onMouseOut="HideTip('tt33')">unpack_ints</a></td><td class=SDescription>The unpack methods extract property values from an array of bits, bytes, or ints. </td></tr>
  <!-- index=40 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_object.do_unpack" id=link43 onMouseOver="ShowTip(event, 'tt34', 'link43')" onMouseOut="HideTip('tt34')">do_unpack</a></td><td class=SDescription>The <i>do_unpack</i> method is the user-definable hook called by the <a href="#uvm_object.unpack" class=LMethod id=link44 onMouseOver="ShowTip(event, 'tt31', 'link44')" onMouseOut="HideTip('tt31')">unpack</a> method. </td></tr>
  <!-- index=41 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_object.Configuration" >Configuration</a></td><td class=SDescription></td></tr>
  <!-- index=42 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.set_int_local" id=link45 onMouseOver="ShowTip(event, 'tt35', 'link45')" onMouseOut="HideTip('tt35')">set_int_local</a></td><td class=SDescription></td></tr>
  <!-- index=43 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.set_string_local" id=link46 onMouseOver="ShowTip(event, 'tt36', 'link46')" onMouseOut="HideTip('tt36')">set_string_local</a></td><td class=SDescription></td></tr>
  <!-- index=44 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_object.set_object_local" id=link47 onMouseOver="ShowTip(event, 'tt37', 'link47')" onMouseOut="HideTip('tt37')">set_object_local</a></td><td class=SDescription>These methods provide write access to integral, string, and uvm_object-based properties indexed by a <i>field_name</i> string. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.new" href="../../src/base/uvm_object.svh">new</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function new (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Creates a new uvm_object with the given instance <i>name</i>.&nbsp; If <i>name</i> is not supplied, the object is unnamed.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Seeding" href="../../src/base/uvm_object.svh">Seeding</a></h3></div></div>




 <!--CONTENT index=3 -->
<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="uvm_object.use_uvm_seeding" href="../../src/base/uvm_object.svh">use_uvm_seeding</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static bit use_uvm_seeding = 1
  </td></tr></table></blockquote><div class=CBody><p>This bit enables or disables the UVM seeding mechanism.&nbsp; It globally affects the operation of the <a href="#uvm_object.reseed" class=LMethod id=link55 onMouseOver="ShowTip(event, 'tt5', 'link55')" onMouseOut="HideTip('tt5')">reseed</a> method.</p><p>When enabled, UVM-based objects are seeded based on their type and full hierarchical name rather than allocation order.&nbsp; This improves random stability for objects whose instance names are unique across each type.&nbsp; The <a href="uvm_component-svh.html#uvm_component" class=LClass id=link56 onMouseOver="ShowTip(event, 'tt38', 'link56')" onMouseOut="HideTip('tt38')">uvm_component</a> class is an example of a type that has a unique instance name.</p></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.reseed" href="../../src/base/uvm_object.svh">reseed</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function void reseed ()
  </td></tr></table></blockquote><div class=CBody><p>Calls <i>srandom</i> on the object to reseed the object using the UVM seeding mechanism, which sets the seed based on type name and instance name instead of based on instance position in a thread.</p><p>If the <a href="#uvm_object.use_uvm_seeding" class=LVariable id=link57 onMouseOver="ShowTip(event, 'tt4', 'link57')" onMouseOut="HideTip('tt4')">use_uvm_seeding</a> static variable is set to 0, then reseed() does not perform any function.</p></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Identification" href="../../src/base/uvm_object.svh">Identification</a></h3></div></div>




 <!--CONTENT index=6 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.set_name" href="../../src/base/uvm_object.svh">set_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void set_name (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Sets the instance name of this object, overwriting any previously given name.</p></div></div></div>




 <!--CONTENT index=7 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_name" href="../../src/base/uvm_object.svh">get_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_name ()
  </td></tr></table></blockquote><div class=CBody><p>Returns the name of the object, as provided by the <i>name</i> argument in the <a href="#uvm_object.new" class=LMethod id=link58 onMouseOver="ShowTip(event, 'tt3', 'link58')" onMouseOut="HideTip('tt3')">new</a> constructor or <a href="#uvm_object.set_name" class=LMethod id=link59 onMouseOver="ShowTip(event, 'tt6', 'link59')" onMouseOut="HideTip('tt6')">set_name</a> method.</p></div></div></div>




 <!--CONTENT index=8 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_full_name" href="../../src/base/uvm_object.svh">get_full_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_full_name ()
  </td></tr></table></blockquote><div class=CBody><p>Returns the full hierarchical name of this object.&nbsp; The default implementation is the same as <a href="#uvm_object.get_name" class=LMethod id=link60 onMouseOver="ShowTip(event, 'tt7', 'link60')" onMouseOut="HideTip('tt7')">get_name</a>, as uvm_objects do not inherently possess hierarchy.</p><p>Objects possessing hierarchy, such as <a href="uvm_component-svh.html#uvm_component" class=LClass id=link61 onMouseOver="ShowTip(event, 'tt38', 'link61')" onMouseOut="HideTip('tt38')">uvm_components</a>, override the default implementation.&nbsp; Other objects might be associated with component hierarchy but are not themselves components.&nbsp; For example, <a href="../seq/uvm_sequence-svh.html#uvm_sequence#(REQ,RSP)" class=LClass id=link62 onMouseOver="ShowTip(event, 'tt39', 'link62')" onMouseOut="HideTip('tt39')">uvm_sequence #(REQ,RSP)</a> classes are typically associated with a <a href="../seq/uvm_sequencer-svh.html#uvm_sequencer#(REQ,RSP)" class=LClass id=link63 onMouseOver="ShowTip(event, 'tt40', 'link63')" onMouseOut="HideTip('tt40')">uvm_sequencer #(REQ,RSP)</a>.&nbsp; In this case, it is useful to override get_full_name to return the sequencer&rsquo;s full name concatenated with the sequence&rsquo;s name.&nbsp; This provides the sequence a full context, which is useful when debugging.</p></div></div></div>




 <!--CONTENT index=9 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_inst_id" href="../../src/base/uvm_object.svh">get_inst_id</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function int get_inst_id ()
  </td></tr></table></blockquote><div class=CBody><p>Returns the object&rsquo;s unique, numeric instance identifier.</p></div></div></div>




 <!--CONTENT index=10 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_inst_count" href="../../src/base/uvm_object.svh">get_inst_count</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static function int get_inst_count()
  </td></tr></table></blockquote><div class=CBody><p>Returns the current value of the instance counter, which represents the total number of uvm_object-based objects that have been allocated in simulation.&nbsp; The instance counter is used to form a unique numeric instance identifier.</p></div></div></div>




 <!--CONTENT index=11 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_type" href="../../src/base/uvm_object.svh">get_type</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static function uvm_object_wrapper get_type ()
  </td></tr></table></blockquote><div class=CBody><p>Returns the type-proxy (wrapper) for this object.&nbsp; The <a href="uvm_factory-svh.html#uvm_factory" class=LClass id=link64 onMouseOver="ShowTip(event, 'tt41', 'link64')" onMouseOut="HideTip('tt41')">uvm_factory</a>&rsquo;s type-based override and creation methods take arguments of <a href="uvm_factory-svh.html#uvm_object_wrapper" class=LClass id=link65 onMouseOver="ShowTip(event, 'tt42', 'link65')" onMouseOut="HideTip('tt42')">uvm_object_wrapper</a>.&nbsp; This method, if implemented, can be used as convenient means of supplying those arguments.</p><p>The default implementation of this method produces an error and returns <i>null</i>.&nbsp; To enable use of this method, a user&rsquo;s subtype must implement a version that returns the subtype&rsquo;s wrapper.</p><h4 class=CHeading>For example</h4><blockquote><pre>class cmd extends uvm_object;
  typedef uvm_object_registry #(cmd) type_id;
  static function type_id get_type();
    return type_id::get();
  endfunction
endclass</pre></blockquote><h4 class=CHeading>Then, to use</h4><blockquote><pre>factory.set_type_override(cmd::get_type(),subcmd::get_type());</pre></blockquote><p>This function is implemented by the `uvm_*_utils macros, if employed.</p></div></div></div>




 <!--CONTENT index=12 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_object_type" href="../../src/base/uvm_object.svh">get_object_type</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function uvm_object_wrapper get_object_type ()
  </td></tr></table></blockquote><div class=CBody><p>Returns the type-proxy (wrapper) for this object.&nbsp; The <a href="uvm_factory-svh.html#uvm_factory" class=LClass id=link66 onMouseOver="ShowTip(event, 'tt41', 'link66')" onMouseOut="HideTip('tt41')">uvm_factory</a>&rsquo;s type-based override and creation methods take arguments of <a href="uvm_factory-svh.html#uvm_object_wrapper" class=LClass id=link67 onMouseOver="ShowTip(event, 'tt42', 'link67')" onMouseOut="HideTip('tt42')">uvm_object_wrapper</a>.&nbsp; This method, if implemented, can be used as convenient means of supplying those arguments.&nbsp; This method is the same as the static <a href="#uvm_object.get_type" class=LMethod id=link68 onMouseOver="ShowTip(event, 'tt11', 'link68')" onMouseOut="HideTip('tt11')">get_type</a> method, but uses an already allocated object to determine the type-proxy to access (instead of using the static object).</p><p>The default implementation of this method does a factory lookup of the proxy using the return value from <a href="#uvm_object.get_type_name" class=LMethod id=link69 onMouseOver="ShowTip(event, 'tt13', 'link69')" onMouseOut="HideTip('tt13')">get_type_name</a>.&nbsp; If the type returned by <a href="#uvm_object.get_type_name" class=LMethod id=link70 onMouseOver="ShowTip(event, 'tt13', 'link70')" onMouseOut="HideTip('tt13')">get_type_name</a> is not registered with the factory, then a <i>null</i> handle is returned.</p><h4 class=CHeading>For example</h4><blockquote><pre>class cmd extends uvm_object;
  typedef uvm_object_registry #(cmd) type_id;
  static function type_id get_type();
    return type_id::get();
  endfunction
  virtual function type_id get_object_type();
    return type_id::get();
  endfunction
endclass</pre></blockquote><p>This function is implemented by the `uvm_*_utils macros, if employed.</p></div></div></div>




 <!--CONTENT index=13 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.get_type_name" href="../../src/base/uvm_object.svh">get_type_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_type_name ()
  </td></tr></table></blockquote><div class=CBody><p>This function returns the type name of the object, which is typically the type identifier enclosed in quotes.&nbsp; It is used for various debugging functions in the library, and it is used by the factory for creating objects.</p><p>This function must be defined in every derived class.</p><h4 class=CHeading>A typical implementation is as follows</h4><blockquote><pre>class mytype extends uvm_object;
  ...
  const static string type_name = &quot;mytype&quot;;

  virtual function string get_type_name();
    return type_name;
  endfunction</pre></blockquote><p>We define the <i>type_name</i> static variable to enable access to the type name without need of an object of the class, i.e., to enable access via the scope operator, <i>mytype::type_name</i>.</p></div></div></div>




 <!--CONTENT index=14 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Creation" href="../../src/base/uvm_object.svh">Creation</a></h3></div></div>




 <!--CONTENT index=15 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.create" href="../../src/base/uvm_object.svh">create</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_object create (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>create</i> method allocates a new object of the same type as this object and returns it via a base uvm_object handle.&nbsp; Every class deriving from uvm_object, directly or indirectly, must implement the create method.</p><h4 class=CHeading>A typical implementation is as follows</h4><blockquote><pre>class mytype extends uvm_object;
  ...
  virtual function uvm_object create(string name=&quot;&quot;);
    mytype t = new(name);
    return t;
  endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=16 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.clone" href="../../src/base/uvm_object.svh">clone</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function uvm_object clone ()
  </td></tr></table></blockquote><div class=CBody><p>The <i>clone</i> method creates and returns an exact copy of this object.</p><p>The default implementation calls <a href="#uvm_object.create" class=LMethod id=link71 onMouseOver="ShowTip(event, 'tt14', 'link71')" onMouseOut="HideTip('tt14')">create</a> followed by <a href="#uvm_object.copy" class=LMethod id=link72 onMouseOver="ShowTip(event, 'tt23', 'link72')" onMouseOut="HideTip('tt23')">copy</a>.&nbsp; As clone is virtual, derived classes may override this implementation if desired.</p></div></div></div>




 <!--CONTENT index=17 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Printing" href="../../src/base/uvm_object.svh">Printing</a></h3></div></div>




 <!--CONTENT index=18 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.print" href="../../src/base/uvm_object.svh">print</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void print (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_printer&nbsp;</td>
      <td class=PParameter nowrap>printer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>print</i> method deep-prints this object&rsquo;s properties in a format and manner governed by the given <i>printer</i> argument; if the <i>printer</i> argument is not provided, the global <a href="uvm_object_globals-svh.html#uvm_default_printer" class=LVariable id=link73 onMouseOver="ShowTip(event, 'tt17', 'link73')" onMouseOut="HideTip('tt17')">uvm_default_printer</a> is used.&nbsp; See <a href="uvm_printer-svh.html#uvm_printer" class=LClass id=link74 onMouseOver="ShowTip(event, 'tt43', 'link74')" onMouseOut="HideTip('tt43')">uvm_printer</a> for more information on printer output formatting.&nbsp; See also <a href="uvm_printer-svh.html#uvm_line_printer" class=LClass id=link75 onMouseOver="ShowTip(event, 'tt44', 'link75')" onMouseOut="HideTip('tt44')">uvm_line_printer</a>, <a href="uvm_printer-svh.html#uvm_tree_printer" class=LClass id=link76 onMouseOver="ShowTip(event, 'tt45', 'link76')" onMouseOut="HideTip('tt45')">uvm_tree_printer</a>, and <a href="uvm_printer-svh.html#uvm_table_printer" class=LClass id=link77 onMouseOver="ShowTip(event, 'tt46', 'link77')" onMouseOut="HideTip('tt46')">uvm_table_printer</a> for details on the pre-defined printer &ldquo;policies,&rdquo; or formatters, provided by the UVM.</p><p>The <i>print</i> method is not virtual and must not be overloaded.&nbsp; To include custom information in the <i>print</i> and <a href="#uvm_object.sprint" class=LMethod id=link78 onMouseOver="ShowTip(event, 'tt18', 'link78')" onMouseOut="HideTip('tt18')">sprint</a> operations, derived classes must override the <a href="#uvm_object.do_print" class=LMethod id=link79 onMouseOver="ShowTip(event, 'tt19', 'link79')" onMouseOut="HideTip('tt19')">do_print</a> method and use the provided printer policy class to format the output.</p></div></div></div>




 <!--CONTENT index=19 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.sprint" href="../../src/base/uvm_object.svh">sprint</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function string sprint (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_printer&nbsp;</td>
      <td class=PParameter nowrap>printer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>sprint</i> method works just like the <a href="#uvm_object.print" class=LMethod id=link80 onMouseOver="ShowTip(event, 'tt16', 'link80')" onMouseOut="HideTip('tt16')">print</a> method, except the output is returned in a string rather than displayed.</p><p>The <i>sprint</i> method is not virtual and must not be overloaded.&nbsp; To include additional fields in the <a href="#uvm_object.print" class=LMethod id=link81 onMouseOver="ShowTip(event, 'tt16', 'link81')" onMouseOut="HideTip('tt16')">print</a> and <i>sprint</i> operation, derived classes must override the <a href="#uvm_object.do_print" class=LMethod id=link82 onMouseOver="ShowTip(event, 'tt19', 'link82')" onMouseOut="HideTip('tt19')">do_print</a> method and use the provided printer policy class to format the output.&nbsp; The printer policy will manage all string concatenations and provide the string to <i>sprint</i> to return to the caller.</p></div></div></div>




 <!--CONTENT index=20 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.do_print" href="../../src/base/uvm_object.svh">do_print</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_print (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_printer&nbsp;</td>
      <td class=PParameter nowrap width=100%>printer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>do_print</i> method is the user-definable hook called by <a href="#uvm_object.print" class=LMethod id=link83 onMouseOver="ShowTip(event, 'tt16', 'link83')" onMouseOut="HideTip('tt16')">print</a> and <a href="#uvm_object.sprint" class=LMethod id=link84 onMouseOver="ShowTip(event, 'tt18', 'link84')" onMouseOut="HideTip('tt18')">sprint</a> that allows users to customize what gets printed or sprinted beyond the field information provided by the `uvm_field_* macros, <a href="../macros/uvm_object_defines-svh.html#Utility_and_Field_Macros_for_Components_and_Objects" class=LSection >Utility and Field Macros for Components and Objects</a>.</p><p>The <i>printer</i> argument is the policy object that governs the format and content of the output.&nbsp; To ensure correct <a href="#uvm_object.print" class=LMethod id=link85 onMouseOver="ShowTip(event, 'tt16', 'link85')" onMouseOut="HideTip('tt16')">print</a> and <a href="#uvm_object.sprint" class=LMethod id=link86 onMouseOver="ShowTip(event, 'tt18', 'link86')" onMouseOut="HideTip('tt18')">sprint</a> operation, and to ensure a consistent output format, the <i>printer</i> must be used by all <a href="#uvm_object.do_print" class=LMethod id=link87 onMouseOver="ShowTip(event, 'tt19', 'link87')" onMouseOut="HideTip('tt19')">do_print</a> implementations.&nbsp; That is, instead of using <i>$display</i> or string concatenations directly, a <i>do_print</i> implementation must call through the <i>printer&rsquo;s</i> API to add information to be printed or sprinted.</p><h4 class=CHeading>An example implementation of <i>do_print</i> is as follows</h4><blockquote><pre>class mytype extends uvm_object;
  data_obj data;
  int f1;
  virtual function void do_print (uvm_printer printer);
    super.do_print(printer);
    printer.print_field_int(&quot;f1&quot;, f1, $bits(f1), UVM_DEC);
    printer.print_object(&quot;data&quot;, data);
  endfunction</pre></blockquote><h4 class=CHeading>Then, to print and sprint the object, you could write</h4><blockquote><pre>mytype t = new;
t.print();
uvm_report_info(&quot;Received&quot;,t.sprint());</pre></blockquote><p>See <a href="uvm_printer-svh.html#uvm_printer" class=LClass id=link88 onMouseOver="ShowTip(event, 'tt43', 'link88')" onMouseOut="HideTip('tt43')">uvm_printer</a> for information about the printer API.</p></div></div></div>




 <!--CONTENT index=21 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.convert2string" href="../../src/base/uvm_object.svh">convert2string</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string convert2string()
  </td></tr></table></blockquote><div class=CBody><p>This virtual function is a user-definable hook, called directly by the user, that allows users to provide object information in the form of a string.&nbsp; Unlike <a href="#uvm_object.sprint" class=LMethod id=link89 onMouseOver="ShowTip(event, 'tt18', 'link89')" onMouseOut="HideTip('tt18')">sprint</a>, there is no requirement to use a <a href="uvm_printer-svh.html#uvm_printer" class=LClass id=link90 onMouseOver="ShowTip(event, 'tt43', 'link90')" onMouseOut="HideTip('tt43')">uvm_printer</a> policy object.&nbsp; As such, the format and content of the output is fully customizable, which may be suitable for applications not requiring the consistent formatting offered by the <a href="#uvm_object.print" class=LMethod id=link91 onMouseOver="ShowTip(event, 'tt16', 'link91')" onMouseOut="HideTip('tt16')">print</a>/<a href="#uvm_object.sprint" class=LMethod id=link92 onMouseOver="ShowTip(event, 'tt18', 'link92')" onMouseOut="HideTip('tt18')">sprint</a>/<a href="#uvm_object.do_print" class=LMethod id=link93 onMouseOver="ShowTip(event, 'tt19', 'link93')" onMouseOut="HideTip('tt19')">do_print</a> API.</p><p>Fields declared in <a href="../macros/uvm_object_defines-svh.html#Utility_Macros" class=LGroup id=link94 onMouseOver="ShowTip(event, 'tt47', 'link94')" onMouseOut="HideTip('tt47')">Utility Macros</a> macros (`uvm_field_*), if used, will not automatically appear in calls to convert2string.</p><p>An example implementation of convert2string follows.</p><blockquote><pre>class base extends uvm_object;
  string field = &quot;foo&quot;;
  virtual function string convert2string();
    convert2string = {&quot;base_field=&quot;,field};
  endfunction
endclass

class obj2 extends uvm_object;
  string field = &quot;bar&quot;;
  virtual function string convert2string();
    convert2string = {&quot;child_field=&quot;,field};
  endfunction
endclass

class obj extends base;
  int addr = 'h123;
  int data = 'h456;
  bit write = 1;
  obj2 child = new;
  virtual function string convert2string();
     convert2string = {super.convert2string(),
       $sformatf(&quot; write=%0d addr=%8h data=%8h &quot;,write,addr,data),
       child.convert2string()};
  endfunction
endclass</pre></blockquote><h4 class=CHeading>Then, to display an object, you could write</h4><blockquote><pre>obj o = new;
uvm_report_info(&quot;BusMaster&quot;,{&quot;Sending:\n &quot;,o.convert2string()});</pre></blockquote><h4 class=CHeading>The output will look similar to</h4><blockquote><pre>UVM_INFO @ 0: reporter [BusMaster] Sending:
   base_field=foo write=1 addr=00000123 data=00000456 child_field=bar</pre></blockquote></div></div></div>




 <!--CONTENT index=22 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Recording" href="../../src/base/uvm_object.svh">Recording</a></h3></div></div>




 <!--CONTENT index=23 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.record" href="../../src/base/uvm_object.svh">record</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void record (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_recorder&nbsp;</td>
      <td class=PParameter nowrap>recorder</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>record</i> method deep-records this object&rsquo;s properties according to an optional <i>recorder</i> policy.&nbsp; The method is not virtual and must not be overloaded.&nbsp; To include additional fields in the record operation, derived classes should override the <a href="#uvm_object.do_record" class=LMethod id=link95 onMouseOver="ShowTip(event, 'tt22', 'link95')" onMouseOut="HideTip('tt22')">do_record</a> method.</p><p>The optional <i>recorder</i> argument specifies the recording policy, which governs how recording takes place.&nbsp; See <a href="uvm_recorder-svh.html#uvm_recorder" class=LClass id=link96 onMouseOver="ShowTip(event, 'tt48', 'link96')" onMouseOut="HideTip('tt48')">uvm_recorder</a> for information.</p><p>A simulator&rsquo;s recording mechanism is vendor-specific.&nbsp; By providing access via a common interface, the uvm_recorder policy provides vendor-independent access to a simulator&rsquo;s recording capabilities.</p></div></div></div>




 <!--CONTENT index=24 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.do_record" href="../../src/base/uvm_object.svh">do_record</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_record (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_recorder&nbsp;</td>
      <td class=PParameter nowrap width=100%>recorder</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>do_record</i> method is the user-definable hook called by the <a href="#uvm_object.record" class=LMethod id=link97 onMouseOver="ShowTip(event, 'tt21', 'link97')" onMouseOut="HideTip('tt21')">record</a> method.&nbsp; A derived class should override this method to include its fields in a record operation.</p><p>The <i>recorder</i> argument is policy object for recording this object.&nbsp; A do_record implementation should call the appropriate recorder methods for each of its fields.&nbsp; Vendor-specific recording implementations are encapsulated in the <i>recorder</i> policy, thereby insulating user-code from vendor-specific behavior.&nbsp; See <a href="uvm_recorder-svh.html#uvm_recorder" class=LClass id=link98 onMouseOver="ShowTip(event, 'tt48', 'link98')" onMouseOut="HideTip('tt48')">uvm_recorder</a> for more information.</p><h4 class=CHeading>A typical implementation is as follows</h4><blockquote><pre>class mytype extends uvm_object;
  data_obj data;
  int f1;
  function void do_record (uvm_recorder recorder);
    recorder.record_field(&quot;f1&quot;, f1, $bits(f1), UVM_DEC);
    recorder.record_object(&quot;data&quot;, data);
  endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=25 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Copying" href="../../src/base/uvm_object.svh">Copying</a></h3></div></div>




 <!--CONTENT index=26 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.copy" href="../../src/base/uvm_object.svh">copy</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void copy (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap width=100%>rhs</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The copy makes this object a copy of the specified object.</p><p>The <i>copy</i> method is not virtual and should not be overloaded in derived classes.&nbsp; To copy the fields of a derived class, that class should override the <a href="#uvm_object.do_copy" class=LMethod id=link99 onMouseOver="ShowTip(event, 'tt24', 'link99')" onMouseOut="HideTip('tt24')">do_copy</a> method.</p></div></div></div>




 <!--CONTENT index=27 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.do_copy" href="../../src/base/uvm_object.svh">do_copy</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_copy (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap width=100%>rhs</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>do_copy</i> method is the user-definable hook called by the <a href="#uvm_object.copy" class=LMethod id=link100 onMouseOver="ShowTip(event, 'tt23', 'link100')" onMouseOut="HideTip('tt23')">copy</a> method.&nbsp; A derived class should override this method to include its fields in a <a href="#uvm_object.copy" class=LMethod id=link101 onMouseOver="ShowTip(event, 'tt23', 'link101')" onMouseOut="HideTip('tt23')">copy</a> operation.</p><h4 class=CHeading>A typical implementation is as follows</h4><blockquote><pre>class mytype extends uvm_object;
  ...
  int f1;
  function void do_copy (uvm_object rhs);
    mytype rhs_;
    super.do_copy(rhs);
    $cast(rhs_,rhs);
    field_1 = rhs_.field_1;
  endfunction</pre></blockquote><p>The implementation must call <i>super.do_copy</i>, and it must $cast the rhs argument to the derived type before copying.</p></div></div></div>




 <!--CONTENT index=28 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Comparing" href="../../src/base/uvm_object.svh">Comparing</a></h3></div></div>




 <!--CONTENT index=29 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.compare" href="../../src/base/uvm_object.svh">compare</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function bit compare (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>rhs,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_comparer&nbsp;</td>
      <td class=PParameter nowrap>comparer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Deep compares members of this data object with those of the object provided in the <i>rhs</i> (right-hand side) argument, returning 1 on a match, 0 otherwise.</p><p>The <i>compare</i> method is not virtual and should not be overloaded in derived classes.&nbsp; To compare the fields of a derived class, that class should override the <a href="#uvm_object.do_compare" class=LMethod id=link102 onMouseOver="ShowTip(event, 'tt26', 'link102')" onMouseOut="HideTip('tt26')">do_compare</a> method.</p><p>The optional <i>comparer</i> argument specifies the comparison policy.&nbsp; It allows you to control some aspects of the comparison operation.&nbsp; It also stores the results of the comparison, such as field-by-field miscompare information and the total number of miscompares.&nbsp; If a compare policy is not provided, then the global <i>uvm_default_comparer</i> policy is used.&nbsp; See <a href="uvm_comparer-svh.html#uvm_comparer" class=LClass id=link103 onMouseOver="ShowTip(event, 'tt49', 'link103')" onMouseOut="HideTip('tt49')">uvm_comparer</a> for more information.</p></div></div></div>




 <!--CONTENT index=30 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.do_compare" href="../../src/base/uvm_object.svh">do_compare</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function bit do_compare (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap width=100%>rhs,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_comparer&nbsp;</td>
      <td class=PParameter nowrap width=100%>comparer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>do_compare</i> method is the user-definable hook called by the <a href="#uvm_object.compare" class=LMethod id=link104 onMouseOver="ShowTip(event, 'tt25', 'link104')" onMouseOut="HideTip('tt25')">compare</a> method.&nbsp; A derived class should override this method to include its fields in a compare operation.&nbsp; It should return 1 if the comparison succeeds, 0 otherwise.</p><h4 class=CHeading>A typical implementation is as follows</h4><blockquote><pre>class mytype extends uvm_object;
  ...
  int f1;
  virtual function bit do_compare (uvm_object rhs,uvm_comparer comparer);
    mytype rhs_;
    do_compare = super.do_compare(rhs,comparer);
    $cast(rhs_,rhs);
    do_compare &amp;= comparer.compare_field_int(&quot;f1&quot;, f1, rhs_.f1);
  endfunction</pre></blockquote><p>A derived class implementation must call <i>super.do_compare()</i> to ensure its base class&rsquo; properties, if any, are included in the comparison.&nbsp; Also, the rhs argument is provided as a generic uvm_object.&nbsp; Thus, you must <i>$cast</i> it to the type of this object before comparing.</p><p>The actual comparison should be implemented using the uvm_comparer object rather than direct field-by-field comparison.&nbsp; This enables users of your class to customize how comparisons are performed and how much miscompare information is collected.&nbsp; See uvm_comparer for more details.</p></div></div></div>




 <!--CONTENT index=31 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Packing" href="../../src/base/uvm_object.svh">Packing</a></h3></div></div>




 <!--CONTENT index=32 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.pack" href="../../src/base/uvm_object.svh">pack</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int pack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>bitstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody></div></div></div>




 <!--CONTENT index=33 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.pack_bytes" href="../../src/base/uvm_object.svh">pack_bytes</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int pack_bytes (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref byte&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>bytestream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody></div></div></div>




 <!--CONTENT index=34 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.pack_ints" href="../../src/base/uvm_object.svh">pack_ints</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int pack_ints (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>intstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The pack methods bitwise-concatenate this object&rsquo;s properties into an array of bits, bytes, or ints.&nbsp; The methods are not virtual and must not be overloaded.&nbsp; To include additional fields in the pack operation, derived classes should override the <a href="#uvm_object.do_pack" class=LMethod id=link105 onMouseOver="ShowTip(event, 'tt30', 'link105')" onMouseOut="HideTip('tt30')">do_pack</a> method.</p><p>The optional <i>packer</i> argument specifies the packing policy, which governs the packing operation.&nbsp; If a packer policy is not provided, the global <a href="uvm_object_globals-svh.html#uvm_default_packer" class=LVariable id=link106 onMouseOver="ShowTip(event, 'tt50', 'link106')" onMouseOut="HideTip('tt50')">uvm_default_packer</a> policy is used.&nbsp; See <a href="uvm_packer-svh.html#uvm_packer" class=LClass id=link107 onMouseOver="ShowTip(event, 'tt51', 'link107')" onMouseOut="HideTip('tt51')">uvm_packer</a> for more information.</p><p>The return value is the total number of bits packed into the given array.&nbsp; Use the array&rsquo;s built-in <i>size</i> method to get the number of bytes or ints consumed during the packing process.</p></div></div></div>




 <!--CONTENT index=35 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.do_pack" href="../../src/base/uvm_object.svh">do_pack</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_pack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap width=100%>packer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>do_pack</i> method is the user-definable hook called by the <a href="#uvm_object.pack" class=LMethod id=link108 onMouseOver="ShowTip(event, 'tt27', 'link108')" onMouseOut="HideTip('tt27')">pack</a> methods.&nbsp; A derived class should override this method to include its fields in a pack operation.</p><p>The <i>packer</i> argument is the policy object for packing.&nbsp; The policy object should be used to pack objects.</p><p>A typical example of an object packing itself is as follows</p><blockquote><pre>class mysubtype extends mysupertype;
  ...
  shortint myshort;
  obj_type myobj;
  byte myarray[];
  ...
  function void do_pack (uvm_packer packer);
    super.do_pack(packer); // pack mysupertype properties
    packer.pack_field_int(myarray.size(), 32);
    foreach (myarray)
      packer.pack_field_int(myarray[index], 8);
    packer.pack_field_int(myshort, $bits(myshort));
    packer.pack_object(myobj);
  endfunction</pre></blockquote><p>The implementation must call <i>super.do_pack</i> so that base class properties are packed as well.</p><p>If your object contains dynamic data (object, string, queue, dynamic array, or associative array), and you intend to unpack into an equivalent data structure when unpacking, you must include meta-information about the dynamic data when packing as follows.</p><ul><li>For queues, dynamic arrays, or associative arrays, pack the number of elements in the array in the 32 bits immediately before packing individual elements, as shown above.</li><li>For string data types, append a zero byte after packing the string contents.</li><li>For objects, pack 4 bits immediately before packing the object.&nbsp; For <i>null</i> objects, pack 4&rsquo;b0000.&nbsp; For non-<i>null</i> objects, pack 4&rsquo;b0001.</li></ul><p>When the `uvm_field_* macros are used, <a href="../macros/uvm_object_defines-svh.html#Utility_and_Field_Macros_for_Components_and_Objects" class=LSection >Utility and Field Macros for Components and Objects</a>, the above meta information is included provided the <a href="uvm_packer-svh.html#uvm_packer.use_metadata" class=LVariable id=link109 onMouseOver="ShowTip(event, 'tt52', 'link109')" onMouseOut="HideTip('tt52')">uvm_packer::use_metadata</a> variable is set for the packer.</p><p>Packing order does not need to match declaration order.&nbsp; However, unpacking order must match packing order.</p></div></div></div>




 <!--CONTENT index=36 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Unpacking" href="../../src/base/uvm_object.svh">Unpacking</a></h3></div></div>




 <!--CONTENT index=37 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.unpack" href="../../src/base/uvm_object.svh">unpack</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int unpack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>bitstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody></div></div></div>




 <!--CONTENT index=38 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.unpack_bytes" href="../../src/base/uvm_object.svh">unpack_bytes</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int unpack_bytes (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref byte&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>bytestream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody></div></div></div>




 <!--CONTENT index=39 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.unpack_ints" href="../../src/base/uvm_object.svh">unpack_ints</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int unpack_ints (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>intstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The unpack methods extract property values from an array of bits, bytes, or ints.&nbsp; The method of unpacking <i>must</i> exactly correspond to the method of packing.&nbsp; This is assured if (a) the same <i>packer</i> policy is used to pack and unpack, and (b) the order of unpacking is the same as the order of packing used to create the input array.</p><p>The unpack methods are fixed (non-virtual) entry points that are directly callable by the user.&nbsp; To include additional fields in the <a href="#uvm_object.unpack" class=LMethod id=link110 onMouseOver="ShowTip(event, 'tt31', 'link110')" onMouseOut="HideTip('tt31')">unpack</a> operation, derived classes should override the <a href="#uvm_object.do_unpack" class=LMethod id=link111 onMouseOver="ShowTip(event, 'tt34', 'link111')" onMouseOut="HideTip('tt34')">do_unpack</a> method.</p><p>The optional <i>packer</i> argument specifies the packing policy, which governs both the pack and unpack operation.&nbsp; If a packer policy is not provided, then the global <i>uvm_default_packer</i> policy is used.&nbsp; See uvm_packer for more information.</p><p>The return value is the actual number of bits unpacked from the given array.</p></div></div></div>




 <!--CONTENT index=40 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.do_unpack" href="../../src/base/uvm_object.svh">do_unpack</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_unpack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap width=100%>packer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The <i>do_unpack</i> method is the user-definable hook called by the <a href="#uvm_object.unpack" class=LMethod id=link112 onMouseOver="ShowTip(event, 'tt31', 'link112')" onMouseOut="HideTip('tt31')">unpack</a> method.&nbsp; A derived class should override this method to include its fields in an unpack operation.</p><p>The <i>packer</i> argument is the policy object for both packing and unpacking.&nbsp; It must be the same packer used to pack the object into bits.&nbsp; Also, do_unpack must unpack fields in the same order in which they were packed.&nbsp; See <a href="uvm_packer-svh.html#uvm_packer" class=LClass id=link113 onMouseOver="ShowTip(event, 'tt51', 'link113')" onMouseOut="HideTip('tt51')">uvm_packer</a> for more information.</p><p>The following implementation corresponds to the example given in do_pack.</p><blockquote><pre>function void do_unpack (uvm_packer packer);
 int sz;
  super.do_unpack(packer); // unpack super's properties
  sz = packer.unpack_field_int(myarray.size(), 32);
  myarray.delete();
  for(int index=0; index&lt;sz; index++)
    myarray[index] = packer.unpack_field_int(8);
  myshort = packer.unpack_field_int($bits(myshort));
  packer.unpack_object(myobj);
endfunction</pre></blockquote><p>If your object contains dynamic data (object, string, queue, dynamic array, or associative array), and you intend to <a href="#uvm_object.unpack" class=LMethod id=link114 onMouseOver="ShowTip(event, 'tt31', 'link114')" onMouseOut="HideTip('tt31')">unpack</a> into an equivalent data structure, you must have included meta-information about the dynamic data when it was packed.</p><ul><li>For queues, dynamic arrays, or associative arrays, unpack the number of elements in the array from the 32 bits immediately before unpacking individual elements, as shown above.</li><li>For string data types, unpack into the new string until a <i>null</i> byte is encountered.</li><li>For objects, unpack 4 bits into a byte or int variable.&nbsp; If the value is 0, the target object should be set to <i>null</i> and unpacking continues to the next property, if any.&nbsp; If the least significant bit is 1, then the target object should be allocated and its properties unpacked.</li></ul></div></div></div>




 <!--CONTENT index=41 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_object.Configuration" href="../../src/base/uvm_object.svh">Configuration</a></h3></div></div>




 <!--CONTENT index=42 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.set_int_local" href="../../src/base/uvm_object.svh">set_int_local</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void set_int_local (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>field_name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_bitstream_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>recurse</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody></div></div></div>




 <!--CONTENT index=43 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.set_string_local" href="../../src/base/uvm_object.svh">set_string_local</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void set_string_local (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>field_name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>recurse</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody></div></div></div>




 <!--CONTENT index=44 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_object.set_object_local" href="../../src/base/uvm_object.svh">set_object_local</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void set_object_local (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>field_name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>clone</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>recurse</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>These methods provide write access to integral, string, and uvm_object-based properties indexed by a <i>field_name</i> string.&nbsp; The object designer choose which, if any, properties will be accessible, and overrides the appropriate methods depending on the properties&rsquo; types.&nbsp; For objects, the optional <i>clone</i> argument specifies whether to clone the <i>value</i> argument before assignment.</p><p>The global <a href="uvm_globals-svh.html#uvm_is_match" class=LMethod id=link115 onMouseOver="ShowTip(event, 'tt53', 'link115')" onMouseOut="HideTip('tt53')">uvm_is_match</a> function is used to match the field names, so <i>field_name</i> may contain wildcards.</p><p>An example implementation of all three methods is as follows.</p><blockquote><pre>class mytype extends uvm_object;

  local int myint;
  local byte mybyte;
  local shortint myshort; // no access
  local string mystring;
  local obj_type myobj;

  // provide access to integral properties
  function void set_int_local(string field_name, uvm_bitstream_t value);
    if (uvm_is_match (field_name, &quot;myint&quot;))
      myint = value;
    else if (uvm_is_match (field_name, &quot;mybyte&quot;))
      mybyte = value;
  endfunction

  // provide access to string properties
  function void set_string_local(string field_name, string value);
    if (uvm_is_match (field_name, &quot;mystring&quot;))
      mystring = value;
  endfunction

  // provide access to sub-objects
  function void set_object_local(string field_name, uvm_object value,
                                 bit clone=1);
    if (uvm_is_match (field_name, &quot;myobj&quot;)) begin
      if (value != null) begin
        obj_type tmp;
        // if provided value is not correct type, produce error
        if (!$cast(tmp, value) )
          /* error */
        else begin
          if(clone)
            $cast(myobj, tmp.clone());
          else
            myobj = tmp;
        end
      end
      else
        myobj = null; // value is null, so simply assign null to myobj
    end
  endfunction
  ...</pre></blockquote><p>Although the object designer implements these methods to provide outside access to one or more properties, they are intended for internal use (e.g., for command-line debugging and auto-configuration) and should not be called directly by the user.</p></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_void
  </td></tr></table></blockquote>The <i>uvm_void</i> class is the base class for all UVM classes. </div></div><div class=CToolTip id="tt2"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_object extends uvm_void
  </td></tr></table></blockquote>The uvm_object class is the base class for all UVM data and hierarchical classes. </div></div><div class=CToolTip id="tt3"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function new (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Creates a new uvm_object with the given instance <i>name</i>. </div></div><div class=CToolTip id="tt4"><div class=CVariable>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static bit use_uvm_seeding = 1
  </td></tr></table></blockquote>This bit enables or disables the UVM seeding mechanism. </div></div><div class=CToolTip id="tt5"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function void reseed ()
  </td></tr></table></blockquote>Calls <i>srandom</i> on the object to reseed the object using the UVM seeding mechanism, which sets the seed based on type name and instance name instead of based on instance position in a thread.</div></div><div class=CToolTip id="tt6"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void set_name (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Sets the instance name of this object, overwriting any previously given name.</div></div><div class=CToolTip id="tt7"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_name ()
  </td></tr></table></blockquote>Returns the name of the object, as provided by the <i>name</i> argument in the new constructor or set_name method.</div></div><div class=CToolTip id="tt8"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_full_name ()
  </td></tr></table></blockquote>Returns the full hierarchical name of this object. </div></div><div class=CToolTip id="tt9"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function int get_inst_id ()
  </td></tr></table></blockquote>Returns the object&rsquo;s unique, numeric instance identifier.</div></div><div class=CToolTip id="tt10"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static function int get_inst_count()
  </td></tr></table></blockquote>Returns the current value of the instance counter, which represents the total number of uvm_object-based objects that have been allocated in simulation. </div></div><div class=CToolTip id="tt11"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static function uvm_object_wrapper get_type ()
  </td></tr></table></blockquote>Returns the type-proxy (wrapper) for this object. </div></div><div class=CToolTip id="tt12"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function uvm_object_wrapper get_object_type ()
  </td></tr></table></blockquote>Returns the type-proxy (wrapper) for this object. </div></div><div class=CToolTip id="tt13"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_type_name ()
  </td></tr></table></blockquote>This function returns the type name of the object, which is typically the type identifier enclosed in quotes. </div></div><div class=CToolTip id="tt14"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_object create (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>create</i> method allocates a new object of the same type as this object and returns it via a base uvm_object handle. </div></div><div class=CToolTip id="tt15"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function uvm_object clone ()
  </td></tr></table></blockquote>The <i>clone</i> method creates and returns an exact copy of this object.</div></div><div class=CToolTip id="tt16"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void print (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_printer&nbsp;</td>
      <td class=PParameter nowrap>printer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>print</i> method deep-prints this object&rsquo;s properties in a format and manner governed by the given <i>printer</i> argument; if the <i>printer</i> argument is not provided, the global uvm_default_printer is used. </div></div><div class=CToolTip id="tt17"><div class=CVariable>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>uvm_printer uvm_default_printer = uvm_default_table_printer
  </td></tr></table></blockquote>The default printer policy. </div></div><div class=CToolTip id="tt18"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function string sprint (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_printer&nbsp;</td>
      <td class=PParameter nowrap>printer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>sprint</i> method works just like the print method, except the output is returned in a string rather than displayed.</div></div><div class=CToolTip id="tt19"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_print (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_printer&nbsp;</td>
      <td class=PParameter nowrap width=100%>printer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>do_print</i> method is the user-definable hook called by print and sprint that allows users to customize what gets printed or sprinted beyond the field information provided by the `uvm_field_* macros, Utility and Field Macros for Components and Objects.</div></div><div class=CToolTip id="tt20"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string convert2string()
  </td></tr></table></blockquote>This virtual function is a user-definable hook, called directly by the user, that allows users to provide object information in the form of a string. </div></div><div class=CToolTip id="tt21"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void record (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_recorder&nbsp;</td>
      <td class=PParameter nowrap>recorder</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>record</i> method deep-records this object&rsquo;s properties according to an optional <i>recorder</i> policy. </div></div><div class=CToolTip id="tt22"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_record (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_recorder&nbsp;</td>
      <td class=PParameter nowrap width=100%>recorder</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>do_record</i> method is the user-definable hook called by the record method. </div></div><div class=CToolTip id="tt23"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void copy (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap width=100%>rhs</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The copy makes this object a copy of the specified object.</div></div><div class=CToolTip id="tt24"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_copy (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap width=100%>rhs</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>do_copy</i> method is the user-definable hook called by the copy method. </div></div><div class=CToolTip id="tt25"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function bit compare (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>rhs,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_comparer&nbsp;</td>
      <td class=PParameter nowrap>comparer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Deep compares members of this data object with those of the object provided in the <i>rhs</i> (right-hand side) argument, returning 1 on a match, 0 otherwise.</div></div><div class=CToolTip id="tt26"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function bit do_compare (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap width=100%>rhs,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_comparer&nbsp;</td>
      <td class=PParameter nowrap width=100%>comparer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>do_compare</i> method is the user-definable hook called by the compare method. </div></div><div class=CToolTip id="tt27"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int pack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>bitstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt28"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int pack_bytes (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref byte&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>bytestream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt29"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int pack_ints (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>intstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The pack methods bitwise-concatenate this object&rsquo;s properties into an array of bits, bytes, or ints. </div></div><div class=CToolTip id="tt30"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_pack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap width=100%>packer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>do_pack</i> method is the user-definable hook called by the pack methods. </div></div><div class=CToolTip id="tt31"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int unpack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>bitstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt32"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int unpack_bytes (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref byte&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>bytestream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt33"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function int unpack_ints (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>intstream[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap>packer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The unpack methods extract property values from an array of bits, bytes, or ints. </div></div><div class=CToolTip id="tt34"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void do_unpack (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_packer&nbsp;</td>
      <td class=PParameter nowrap width=100%>packer</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The <i>do_unpack</i> method is the user-definable hook called by the unpack method. </div></div><div class=CToolTip id="tt35"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void set_int_local (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>field_name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_bitstream_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>recurse</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt36"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void set_string_local (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>field_name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>recurse</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt37"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void set_object_local (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>field_name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>clone</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>recurse</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
These methods provide write access to integral, string, and uvm_object-based properties indexed by a <i>field_name</i> string. </div></div><div class=CToolTip id="tt38"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_component extends uvm_report_object
  </td></tr></table></blockquote>The uvm_component class is the root base class for UVM components. </div></div><div class=CToolTip id="tt39"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual class uvm_sequence #(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>type&nbsp;</td>
      <td class=PParameter nowrap>REQ</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> uvm_sequence_item,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>type&nbsp;</td>
      <td class=PParameter nowrap>RSP</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> REQ</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>) extends uvm_sequence_base</td></tr>
      </table></td></tr>
    </table></blockquote>
The uvm_sequence class provides the interfaces necessary in order to create streams of sequence items and/or other sequences.</div></div><div class=CToolTip id="tt40"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>class uvm_sequencer #(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>type&nbsp;</td>
      <td class=PParameter nowrap>REQ</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>uvm_sequence_item,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>&nbsp;</td>
      <td class=PParameter nowrap>RSP</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>REQ</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>) extends uvm_sequencer_param_base #(REQ, RSP)</td></tr>
      </table></td></tr>
    </table></blockquote>
</div></div><div class=CToolTip id="tt41"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_factory
  </td></tr></table></blockquote>As the name implies, uvm_factory is used to manufacture (create) UVM objects and components. </div></div><div class=CToolTip id="tt42"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_object_wrapper
  </td></tr></table></blockquote>The uvm_object_wrapper provides an abstract interface for creating object and component proxies. </div></div><div class=CToolTip id="tt43"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_printer
  </td></tr></table></blockquote>The uvm_printer class provides an interface for printing uvm_objects in various formats. </div></div><div class=CToolTip id="tt44"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_line_printer extends uvm_tree_printer
  </td></tr></table></blockquote>The line printer prints output in a line format.</div></div><div class=CToolTip id="tt45"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_tree_printer extends uvm_printer
  </td></tr></table></blockquote>By overriding various methods of the uvm_printer super class, the tree printer prints output in a tree format.</div></div><div class=CToolTip id="tt46"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_table_printer extends uvm_printer
  </td></tr></table></blockquote>The table printer prints output in a tabular format.</div></div><div class=CToolTip id="tt47"><div class=CGroup>The <i>utils</i> macros define the infrastructure needed to enable the object/component for correct factory operation. </div></div><div class=CToolTip id="tt48"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_recorder extends uvm_object
  </td></tr></table></blockquote>Abstract class which defines the <i>recorder</i> API.</div></div><div class=CToolTip id="tt49"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_comparer
  </td></tr></table></blockquote>The uvm_comparer class provides a policy object for doing comparisons. </div></div><div class=CToolTip id="tt50"><div class=CVariable>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>uvm_packer uvm_default_packer = new()
  </td></tr></table></blockquote>The default packer policy. </div></div><div class=CToolTip id="tt51"><div class=CClass>The uvm_packer class provides a policy object for packing and unpacking uvm_objects. </div></div><div class=CToolTip id="tt52"><div class=CVariable>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>bit use_metadata
  </td></tr></table></blockquote>This flag indicates whether to encode metadata when packing dynamic data, or to decode metadata when unpacking. </div></div><div class=CToolTip id="tt53"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function bit uvm_is_match (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>expr,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>str</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns 1 if the two strings match, 0 otherwise.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>