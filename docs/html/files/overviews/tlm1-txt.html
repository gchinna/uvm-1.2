<html><head><title>TLM1 Interfaces, Ports, Exports and Transport Interfaces</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script language=JavaScript src="../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="TLM1_Interfaces,Ports,Exports_and_Transport_Interfaces" href="../../src/overviews/tlm1.txt">TLM1 Interfaces, Ports, Exports and Transport Interfaces</a></h1><div class=CBody><p>Each TLM1 interface is either blocking, non-blocking, or a combination of these two.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>blocking</td><td class=CDLDescription>A blocking interface conveys transactions in blocking fashion; its methods do not return until the transaction has been successfully sent or retrieved.&nbsp; Because delivery may consume time to complete, the methods in such an interface are declared as tasks.</td></tr><tr><td class=CDLEntry>non-blocking</td><td class=CDLDescription>A non-blocking interface attempts to convey a transaction without consuming simulation time.&nbsp; Its methods are declared as functions.&nbsp; Because delivery may fail (e.g. the target component is busy and can not accept the request), the methods may return with failed status.</td></tr><tr><td class=CDLEntry>combination</td><td class=CDLDescription>A combination interface contains both the blocking and non-blocking variants.&nbsp;  In SystemC, combination interfaces are defined through multiple inheritance.&nbsp;  Because SystemVerilog does not support multiple inheritance, the UVM emulates hierarchical interfaces via a common base class and interface mask.</td></tr></table><p>Like their SystemC counterparts, the UVM&rsquo;s TLM port and export implementations allow connections between ports whose interfaces are not an exact match.&nbsp; For example, a <i>uvm_blocking_get_port</i> can be connected to any port, export or imp port that provides <i>at the least</i> an implementation of the blocking_get interface, which includes the <i>uvm_get_*</i> ports and exports, <i>uvm_blocking_get_peek_*</i> ports and exports, and <i>uvm_get_peek_*</i> ports and exports.</p><p>The sections below provide and overview of the unidirectional and bidirectional TLM interfaces, ports, and exports.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#TLM1_Interfaces,Ports,Exports_and_Transport_Interfaces" >TLM1 Interfaces, Ports, Exports and Transport Interfaces</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Each TLM1 interface is either blocking, non-blocking, or a combination of these two.</td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Unidirectional_InterfacesPorts" >Unidirectional Interfaces &amp; Ports</a></td><td class=SDescription>The unidirectional TLM interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the <i>put</i>, <i>get</i> and <i>peek</i> interfaces, plus a non-blocking <i>analysis</i> interface.</td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Put" >Put</a></td><td class=SDescription>The <i>put</i> interfaces are used to send, or <i>put</i>, transactions to other components. </td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Get_and_Peek" >Get and Peek</a></td><td class=SDescription>The <i>get</i> interfaces are used to retrieve transactions from other components. </td></tr>
  <!-- index=4 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Ports,Exports,and_Imps" >Ports, Exports, and Imps</a></td><td class=SDescription>The UVM provides unidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces.</td></tr>
  <!-- index=5 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Bidirectional_InterfacesPorts" >Bidirectional Interfaces &amp; Ports</a></td><td class=SDescription>The bidirectional interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the <i>transport</i>, <i>master</i>, and <i>slave</i> interfaces.</td></tr>
  <!-- index=6 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Transport" >Transport</a></td><td class=SDescription>The <i>transport</i> interface sends a request transaction and returns a response transaction in a single task call, thereby enforcing an in-order execution semantic. </td></tr>
  <!-- index=7 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#Master_and_Slave" >Master and Slave</a></td><td class=SDescription>The primitive, unidirectional <i>put</i>, <i>get</i>, and <i>peek</i> interfaces are combined to form bidirectional master and slave interfaces. </td></tr>
  <!-- index=8 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#Ports,Exports,and_Imps" >Ports, Exports, and Imps</a></td><td class=SDescription>The UVM provides bidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces.</td></tr>
  <!-- index=9 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#Usage" >Usage</a></td><td class=SDescription>This example illustrates basic TLM connectivity using the blocking put interface.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Unidirectional_InterfacesPorts" href="../../src/overviews/tlm1.txt">Unidirectional Interfaces &amp; Ports</a></h3><div class=CBody><p>The unidirectional TLM interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the <i>put</i>, <i>get</i> and <i>peek</i> interfaces, plus a non-blocking <i>analysis</i> interface.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Put" href="../../src/overviews/tlm1.txt">Put</a></h3><div class=CBody><p>The <i>put</i> interfaces are used to send, or <i>put</i>, transactions to other components.&nbsp; Successful completion of a put guarantees its delivery, not execution.</p><img src="../../images/uvm_ref_tlm_put_ifs.gif" width="261" height="172"></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Get_and_Peek" href="../../src/overviews/tlm1.txt">Get and Peek</a></h3><div class=CBody><p>The <i>get</i> interfaces are used to retrieve transactions from other components.&nbsp; The <i>peek</i> interfaces are used for the same purpose, except the retrieved transaction is not consumed; successive calls to <i>peek</i> will return the same object.&nbsp; Combined <i>get_peek</i> interfaces are also defined.</p><img src="../../images/uvm_ref_tlm_get_peek_ifs.gif" width="527" height="470"></div></div></div>




 <!--CONTENT index=4 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Ports,Exports,and_Imps" href="../../src/overviews/tlm1.txt">Ports, Exports, and Imps</a></h3><div class=CBody><p>The UVM provides unidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Ports</td><td class=CDLDescription>instantiated in components that <i>require</i>, or <i>use</i>, the associate interface to initiate transaction requests.</td></tr><tr><td class=CDLEntry>Exports</td><td class=CDLDescription>instantiated by components that <i>forward</i> an implementation of the methods defined in the associated interface.&nbsp; The implementation is typically provided by an <i>imp</i> port in a child component.</td></tr><tr><td class=CDLEntry>Imps</td><td class=CDLDescription>instantiated by components that <i>provide</i> or <i>implement</i> an implementation of the methods defined in the associated interface.</td></tr></table><img src="../../images/uvm_ref_tlm_uni_ports.gif" width="397" height="227"><p>A summary of port, export, and imp declarations are</p><blockquote><pre>class uvm_*_export #(type T=int)
  extends uvm_port_base #(tlm_if_base #(T,T));

class uvm_*_port #(type T=int)
  extends uvm_port_base #(tlm_if_base #(T,T));

class uvm_*_imp #(type T=int)
  extends uvm_port_base #(tlm_if_base #(T,T));</pre></blockquote><p>where the asterisk can be any of</p><blockquote><pre>blocking_put
nonblocking_put
put

blocking_get
nonblocking_get
get

blocking_peek
nonblocking_peek
peek

blocking_get_peek
nonblocking_get_peek
get_peek

analysis</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Bidirectional_InterfacesPorts" href="../../src/overviews/tlm1.txt">Bidirectional Interfaces &amp; Ports</a></h3><div class=CBody><p>The bidirectional interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the <i>transport</i>, <i>master</i>, and <i>slave</i> interfaces.</p><p>Bidirectional interfaces involve both a transaction request and response.</p></div></div></div>




 <!--CONTENT index=6 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Transport" href="../../src/overviews/tlm1.txt">Transport</a></h3><div class=CBody><p>The <i>transport</i> interface sends a request transaction and returns a response transaction in a single task call, thereby enforcing an in-order execution semantic.&nbsp; The request and response transactions can be different types.</p><img src="../../images/uvm_ref_tlm_transport_ifs.gif" width="322" height="160"></div></div></div>




 <!--CONTENT index=7 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Master_and_Slave" href="../../src/overviews/tlm1.txt">Master and Slave</a></h3><div class=CBody><p>The primitive, unidirectional <i>put</i>, <i>get</i>, and <i>peek</i> interfaces are combined to form bidirectional master and slave interfaces.&nbsp; The master puts requests and gets or peeks responses.&nbsp; The slave gets or peeks requests and puts responses.&nbsp; Because the put and the get come from different function interface methods, the requests and responses are not coupled as they are with the <i>transport</i> interface.</p><img src="../../images/uvm_ref_tlm_master_slave_ifs.gif" width="611" height="451"></div></div></div>




 <!--CONTENT index=8 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Ports,Exports,and_Imps" href="../../src/overviews/tlm1.txt">Ports, Exports, and Imps</a></h3><div class=CBody><p>The UVM provides bidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Ports</td><td class=CDLDescription>instantiated in components that <i>require</i>, or <i>use</i>, the associate interface to initiate transaction requests.</td></tr><tr><td class=CDLEntry>Exports</td><td class=CDLDescription>instantiated by components that <i>forward</i> an implementation of the methods defined in the associated interface.&nbsp; The implementation is typically provided by an <i>imp</i> port in a child component.</td></tr><tr><td class=CDLEntry>Imps</td><td class=CDLDescription>instantiated by components that <i>provide</i> or <i>implement</i> an implementation of the methods defined in the associated interface.</td></tr></table><img src="../../images/uvm_ref_tlm_bidir_ports.gif" width="409" height="227"><p>A summary of port, export, and imp declarations are</p><blockquote><pre>class uvm_*_port #(type REQ=int, RSP=int)
  extends uvm_port_base #(tlm_if_base #(REQ, RSP));

class uvm_*_export #(type REQ=int, RSP=int)
  extends uvm_port_base #(tlm_if_base #(REQ, RSP));

class uvm_*_imp #(type REQ=int, RSP=int)
  extends uvm_port_base #(tlm_if_base #(REQ, RSP));</pre></blockquote><p>where the asterisk can be any of</p><blockquote><pre>transport
blocking_transport
nonblocking_transport

blocking_master
nonblocking_master
master

blocking_slave
nonblocking_slave
slave</pre></blockquote></div></div></div>




 <!--CONTENT index=9 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Usage" href="../../src/overviews/tlm1.txt">Usage</a></h3><div class=CBody><p>This example illustrates basic TLM connectivity using the blocking put interface.</p><img src="../../images/uvm_ref_tlm_hierarchy.gif" width="486" height="236"><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>port-to-port</td><td class=CDLDescription>leaf1&rsquo;s <i>out</i> port is connected to its parent&rsquo;s (comp1) <i>out</i> port</td></tr><tr><td class=CDLEntry>port-to-export</td><td class=CDLDescription>comp1&rsquo;s <i>out</i> port is connected to comp2&rsquo;s <i>in</i> export</td></tr><tr><td class=CDLEntry>export-to-export</td><td class=CDLDescription>comp2&rsquo;s <i>in</i> export is connected to its child&rsquo;s (subcomp2) <i>in</i> export</td></tr><tr><td class=CDLEntry>export-to-imp</td><td class=CDLDescription>subcomp2&rsquo;s <i>in</i> export is connected leaf2&rsquo;s <i>in</i> imp port.</td></tr><tr><td class=CDLEntry>imp-to-implementation</td><td class=CDLDescription>leaf2&rsquo;s <i>in</i> imp port is connected to its implementation, leaf2</td></tr></table><p>Hierarchical port connections are resolved and optimized just before <a href="../base/uvm_component-svh.html#uvm_component.end_of_elaboration_phase" class=LMethod id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">uvm_component::end_of_elaboration_phase</a>.&nbsp; After optimization, calling any port&rsquo;s interface method (e.g. leaf1.out.put(trans)) incurs a single hop to get to the implementation (e.g. leaf2&rsquo;s put task), no matter how far up and down the hierarchy the implementation resides.</p><blockquote><pre>`include &quot;uvm_pkg.sv&quot;
import uvm_pkg::*;

class trans extends uvm_transaction;
  rand int addr;
  rand int data;
  rand bit write;
endclass

class leaf1 extends uvm_component;

  `uvm_component_utils(leaf1)

  uvm_blocking_put_port #(trans) out;

  function new(string name, uvm_component parent=null);
    super.new(name,parent);
    out = new(&quot;out&quot;,this);
  endfunction

  virtual task run_phase(uvm_phase phase);
    trans t;
    phase.raise_objection(this, &quot;prolonging run_phase&quot;);
    t = new;
    t.randomize();
    out.put(t);
    phase.drop_objection(this, &quot;prolonging run_phase&quot;);
  endtask

endclass


class comp1 extends uvm_component;

  `uvm_component_utils(comp1)

  uvm_blocking_put_port #(trans) out;

  leaf1 leaf;

  function new(string name, uvm_component parent=null);
    super.new(name,parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    out = new(&quot;out&quot;,this);
    leaf = new(&quot;leaf1&quot;,this);
  endfunction

  // connect port to port
  virtual function void connect_phase(uvm_phase phase);
    leaf.out.connect(out);
  endfunction

endclass


class leaf2 extends uvm_component;

  `uvm_component_utils(leaf2)

  uvm_blocking_put_imp #(trans,leaf2) in;

  function new(string name, uvm_component parent=null);
    super.new(name,parent);
    // connect imp to implementation (this)
    in = new(&quot;in&quot;,this);
  endfunction

  virtual task put(trans t);
    $display(&quot;Got trans: addr=%0d, data=%0d, write=%0d&quot;,
        t.addr, t.data, t.write);
  endtask

endclass


class subcomp2 extends uvm_component;

  `uvm_component_utils(subcomp2)

  uvm_blocking_put_export #(trans) in;

  leaf2 leaf;

  function new(string name, uvm_component parent=null);
    super.new(name,parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    in = new(&quot;in&quot;,this);
    leaf = new(&quot;leaf2&quot;,this);
  endfunction

  // connect export to imp
  virtual function void connect_phase(uvm_phase phase);
    in.connect(leaf.in);
  endfunction

endclass


class comp2 extends uvm_component;

  `uvm_component_utils(comp2)

  uvm_blocking_put_export #(trans) in;

  subcomp2 subcomp;

  function new(string name, uvm_component parent=null);
    super.new(name,parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    in = new(&quot;in&quot;,this);
    subcomp = new(&quot;subcomp2&quot;,this);
  endfunction

  // connect export to export
  virtual function void connect_phase(uvm_phase phase);
    in.connect(subcomp.in);
  endfunction

endclass


class env extends uvm_component;

  `uvm_component_utils(comp1)

  comp1 comp1_i;
  comp2 comp2_i;

  function new(string name, uvm_component parent=null);
    super.new(name,parent);
  endfunction

  virtual function void build_phase(uvm_phase phase);
    comp1_i = new(&quot;comp1&quot;,this);
    comp2_i = new(&quot;comp2&quot;,this);
  endfunction

  // connect port to export
  virtual function void connect_phase(uvm_phase phase);
    comp1_i.out.connect(comp2_i.in);
  endfunction

endclass


module top;
  env e = new(&quot;env&quot;);
  initial run_test();
  initial #10 uvm_top.stop_request();
endmodule</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void end_of_elaboration_phase(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_phase&nbsp;</td>
      <td class=PParameter nowrap width=100%>phase</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The uvm_end_of_elaboration_phase phase implementation method.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>