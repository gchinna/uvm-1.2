<html><head><title>TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script language=JavaScript src="../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="TLM2_Interfaces,Ports,Exports_and_Transport_Interfaces_Subset" href="../../src/overviews/tlm2.txt">TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset</a></h1><div class=CBody><p>Sockets group together all the necessary core interfaces for transportation and binding, allowing more generic usage models than just TLM core interfaces.</p><p>A socket is like a port or export; in fact it is derived from the same base class as ports and export, namely <a href="../base/uvm_port_base-svh.html#uvm_port_base#(IF)" class=LClass id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">uvm_port_base #(IF)</a>.&nbsp; However, unlike a port or export a socket provides both a forward and backward path.&nbsp; Thus you can enable asynchronous (pipelined) bi-directional communication by connecting sockets together.&nbsp; To enable this, a socket contains both a port and an export.&nbsp; Components that initiate transactions are called initiators, and components that receive transactions sent by an initiator are called targets.&nbsp; Initiators have initiator sockets and targets have target sockets.&nbsp; Initiator sockets can connect to target sockets.&nbsp; You cannot connect initiator sockets to other initiator sockets and you cannot connect target sockets to target sockets.</p><h4 class=CHeading>The UVM TLM2 subset provides the following two transport interfaces</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Blocking (b_transport)</td><td class=CDLDescription>completes the entire transaction within a single method call</td></tr><tr><td class=CDLEntry>Non-blocking (nb_transport)</td><td class=CDLDescription>describes the progress of a transaction using multiple nb_transport() method calls going back-and-forth between initiator and target</td></tr></table><p>In general, any component might modify a transaction object during its lifetime (subject to the rules of the protocol).&nbsp; Significant timing points during the lifetime of a transaction (for example: start of response- phase) are indicated by calling nb_transport() in either forward or backward direction, the specific timing point being given by the phase argument.&nbsp; Protocol-specific rules for reading or writing the attributes of a transaction can be expressed relative to the phase.&nbsp; The phase can be used for flow control, and for that reason might have a different value at each hop taken by a transaction; the phase is not an attribute of the transaction object.</p><p>A call to nb_transport() always represents a phase transition.&nbsp; However, the return from nb_transport() might or might not do so, the choice being indicated by the value returned from the function (<a href="../tlm2/uvm_tlm2_ifs-svh.html#UVM_TLM_ACCEPTED" class=LConstant id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">UVM_TLM_ACCEPTED</a> versus <a href="../tlm2/uvm_tlm2_ifs-svh.html#UVM_TLM_UPDATED" class=LConstant id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">UVM_TLM_UPDATED</a>).&nbsp; Generally, you indicate the completion of a transaction over a particular hop using the value of the phase argument.&nbsp; As a shortcut, a target might indicate the completion of the transaction by returning a special value of <a href="../tlm2/uvm_tlm2_ifs-svh.html#UVM_TLM_COMPLETED" class=LConstant id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">UVM_TLM_COMPLETED</a>.&nbsp; However, this is an option, not a necessity.</p><p>The transaction object itself does not contain any timing information by design.&nbsp; Or even events and status information concerning the API.&nbsp; You can pass the delays as arguments to b_transport()/ nb_transport() and push the actual realization of any delay in the simulator kernel downstream and defer (for simulation speed).</p><h4 class=CHeading>Use Models</h4><p>Since sockets are derived from <a href="../base/uvm_port_base-svh.html#uvm_port_base#(IF)" class=LClass id=link5 onMouseOver="ShowTip(event, 'tt1', 'link5')" onMouseOut="HideTip('tt1')">uvm_port_base #(IF)</a> they are created and connected in the same way as port, and exports.&nbsp; Create them in the build phase and connect them in the connect phase by calling connect().&nbsp; Initiator and target termination sockets are on the ends of any connection.&nbsp; There can be an arbitrary number of pass-through sockets in the path between initiator and target.&nbsp; Some socket types must be bound to imps  implementations of the transport tasks and functions.&nbsp; Blocking terminator sockets must be bound to an implementation of b_transport(), for example.&nbsp; Nonblocking initiator sockets must be bound to an implementation of nb_transport_bw() and nonblocking target sockets must be bound to an implementation of nb_transport_fw().&nbsp; Typically, the task or function is implemented in the component in which the socket is instantiated and the component type and instance are provided to complete the binding.</p><p>Consider for example a consumer component with a blocking target socket.</p><h4 class=CHeading>Example</h4><blockquote><pre>class consumer extends uvm_component;
   tlm2_b_target_socket #(consumer, trans) target_socket;
   function new(string name, uvm_component parent);
     super.new(name, parent);
   endfunction
   function void build();
     target_socket = new(&quot;target_socket&quot;, this, this);
   endfunction
   task b_transport(trans t, uvm_tlm_time delay);
     #5;
     uvm_report_info(&quot;consumer&quot;, t.convert2string());
   endtask
endclass</pre></blockquote><p>The interface task b_transport() is implemented in the consumer component.&nbsp; The consumer component type is used in the declaration of the target socket.&nbsp; This informs the socket object the type of the object that contains the interface task, in this case b_transport().&nbsp; When the socket is instantiated &ldquo;this&rdquo; is passed in twice, once as the parent just like any other component instantiation and again to identify the object that holds the implementation of b_transport().&nbsp; Finally, in order to complete the binding, an implementation of b_transport() must be present in the consumer component.&nbsp; Any component that has either a blocking termination socket, a nonblocking initiator socket, or a nonblocking termination socket must provide implementations of the relevant components.&nbsp; This includes initiator and target components as well as interconnect components that have these kinds of sockets.&nbsp; Components with pass-through sockets do not need to provide implementations of any sort.&nbsp; Of course, they must ultimately be connected to sockets that do that the necessary implementations.</p><h4 class=CHeading>In summary</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Call to b_transport()</td><td class=CDLDescription>start-of-life of transaction</td></tr><tr><td class=CDLEntry>Return from b_transport()</td><td class=CDLDescription>end-of-life of transaction</td></tr><tr><td class=CDLEntry>Phase argument to nb_transport()</td><td class=CDLDescription>timing point within lifetime of transaction</td></tr><tr><td class=CDLEntry>Return value of nb_transport()</td><td class=CDLDescription>whether return path is being used (also shortcut to final phase)</td></tr><tr><td class=CDLEntry>Response status within transaction object</td><td class=CDLDescription>protocol-specific status, success/failure of transaction</td></tr></table><p>On top of this, TLM-2.0 defines a generic payload and base protocol to enhance interoperability for models with a memory-mapped bus interface.</p><p>It is possible to use the interfaces described above with user-defined transaction types and protocols for the sake of interoperability.&nbsp; However, TLM-2.0 strongly recommends either using the base protocol off-the-shelf or creating models of specific protocols on top of the base protocol.</p><p>The UVM 1.2 standard only defines and supports this TLM2 style interface for SystemVerilog to SystemVerilog communication.&nbsp; Mixed language TLM communication is saved for future extension.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#TLM2_Interfaces,Ports,Exports_and_Transport_Interfaces_Subset" >TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Sockets group together all the necessary core interfaces for transportation and binding, allowing more generic usage models than just TLM core interfaces.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual class uvm_port_base #(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>type&nbsp;</td>
      <td class=PParameter nowrap>IF</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>uvm_void</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>) extends IF</td></tr>
      </table></td></tr>
    </table></blockquote>
Transaction-level communication between components is handled via its ports, exports, and imps, all of which derive from this class.</div></div><div class=CToolTip id="tt2"><div class=CConstant>Transaction has been accepted</div></div><div class=CToolTip id="tt3"><div class=CConstant>Transaction has been modified</div></div><div class=CToolTip id="tt4"><div class=CConstant>Execution of transaction is complete</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>