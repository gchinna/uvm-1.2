<html><head><title>uvm_mem</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script language=JavaScript src="../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CClass"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="uvm_mem" href="../../src/reg/uvm_mem.svh">uvm_mem</a></h1><div class=CBody><p>Memory abstraction base class</p><p>A memory is a collection of contiguous locations.&nbsp; A memory may be accessible via more than one address map.</p><p>Unlike registers, memories are not mirrored because of the potentially large data space: tests that walk the entire memory space would negate any benefit from sparse memory modelling techniques.&nbsp; Rather than relying on a mirror, it is recommended that backdoor access be used instead.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#uvm_mem" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">uvm_mem</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>Memory abstraction base class</td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry><a href="../base/uvm_misc-svh.html#uvm_void" class=LClass id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">uvm_void</a></div></div></td></tr>
          <tr><td><div class=CHParent><div class=CHEntry><a href="../base/uvm_object-svh.html#uvm_object" class=LClass id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">uvm_object</a></div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>uvm_mem</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_mem extends uvm_object
  </td></tr></table></blockquote></td></tr>

  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.Initialization" >Initialization</a></td><td class=SDescription></td></tr>
  <!-- index=2 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.new" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">new</a></td><td class=SDescription>Create a new instance and type-specific configuration</td></tr>
  <!-- index=3 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.configure" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">configure</a></td><td class=SDescription>Instance-specific configuration</td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.set_offset" >set_offset</a></td><td class=SDescription>Modify the offset of the memory</td></tr>
  <!-- index=5 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.Modifying_the_offset_of_a_memory_will_make_the_abstract_model" >Modifying the offset of a memory will make the abstract model</a></td><td class=SDescription>diverge from the specification that was used to create it.</td></tr>
  <!-- index=6 -->

<tr class="SVariable SIndent2"><td class=SEntry><a href="#uvm_mem.mam" id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">mam</a></td><td class=SDescription>Memory allocation manager</td></tr>
  <!-- index=7 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.Introspection" >Introspection</a></td><td class=SDescription></td></tr>
  <!-- index=8 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_name" >get_name</a></td><td class=SDescription>Get the simple name</td></tr>
  <!-- index=9 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_full_name" id=link7 onMouseOver="ShowTip(event, 'tt7', 'link7')" onMouseOut="HideTip('tt7')">get_full_name</a></td><td class=SDescription>Get the hierarchical name</td></tr>
  <!-- index=10 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_parent" id=link8 onMouseOver="ShowTip(event, 'tt8', 'link8')" onMouseOut="HideTip('tt8')">get_parent</a></td><td class=SDescription>Get the parent block</td></tr>
  <!-- index=11 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_n_maps" id=link9 onMouseOver="ShowTip(event, 'tt9', 'link9')" onMouseOut="HideTip('tt9')">get_n_maps</a></td><td class=SDescription>Returns the number of address maps this memory is mapped in</td></tr>
  <!-- index=12 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.is_in_map" id=link10 onMouseOver="ShowTip(event, 'tt10', 'link10')" onMouseOut="HideTip('tt10')">is_in_map</a></td><td class=SDescription>Return TRUE if this memory is in the specified address <i>map</i></td></tr>
  <!-- index=13 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_maps" id=link11 onMouseOver="ShowTip(event, 'tt11', 'link11')" onMouseOut="HideTip('tt11')">get_maps</a></td><td class=SDescription>Returns all of the address <i>maps</i> where this memory is mapped</td></tr>
  <!-- index=14 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_rights" id=link12 onMouseOver="ShowTip(event, 'tt12', 'link12')" onMouseOut="HideTip('tt12')">get_rights</a></td><td class=SDescription>Returns the access rights of this memory.</td></tr>
  <!-- index=15 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_access" id=link13 onMouseOver="ShowTip(event, 'tt13', 'link13')" onMouseOut="HideTip('tt13')">get_access</a></td><td class=SDescription>Returns the access policy of the memory when written and read via an address map.</td></tr>
  <!-- index=16 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_size" id=link14 onMouseOver="ShowTip(event, 'tt14', 'link14')" onMouseOut="HideTip('tt14')">get_size</a></td><td class=SDescription>Returns the number of unique memory locations in this memory.</td></tr>
  <!-- index=17 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_n_bytes" id=link15 onMouseOver="ShowTip(event, 'tt15', 'link15')" onMouseOut="HideTip('tt15')">get_n_bytes</a></td><td class=SDescription>Return the width, in number of bytes, of each memory location</td></tr>
  <!-- index=18 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_n_bits" id=link16 onMouseOver="ShowTip(event, 'tt16', 'link16')" onMouseOut="HideTip('tt16')">get_n_bits</a></td><td class=SDescription>Returns the width, in number of bits, of each memory location</td></tr>
  <!-- index=19 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_max_size" id=link17 onMouseOver="ShowTip(event, 'tt17', 'link17')" onMouseOut="HideTip('tt17')">get_max_size</a></td><td class=SDescription>Returns the maximum width, in number of bits, of all memories</td></tr>
  <!-- index=20 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_virtual_registers" id=link18 onMouseOver="ShowTip(event, 'tt18', 'link18')" onMouseOut="HideTip('tt18')">get_virtual_registers</a></td><td class=SDescription>Return the virtual registers in this memory</td></tr>
  <!-- index=21 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_virtual_fields" id=link19 onMouseOver="ShowTip(event, 'tt19', 'link19')" onMouseOut="HideTip('tt19')">get_virtual_fields</a></td><td class=SDescription>Return  the virtual fields in the memory</td></tr>
  <!-- index=22 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_vreg_by_name" id=link20 onMouseOver="ShowTip(event, 'tt20', 'link20')" onMouseOut="HideTip('tt20')">get_vreg_by_name</a></td><td class=SDescription>Find the named virtual register</td></tr>
  <!-- index=23 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_vfield_by_name" id=link21 onMouseOver="ShowTip(event, 'tt21', 'link21')" onMouseOut="HideTip('tt21')">get_vfield_by_name</a></td><td class=SDescription>Find the named virtual field</td></tr>
  <!-- index=24 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_vreg_by_offset" id=link22 onMouseOver="ShowTip(event, 'tt22', 'link22')" onMouseOut="HideTip('tt22')">get_vreg_by_offset</a></td><td class=SDescription>Find the virtual register implemented at the specified offset</td></tr>
  <!-- index=25 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_offset" id=link23 onMouseOver="ShowTip(event, 'tt23', 'link23')" onMouseOut="HideTip('tt23')">get_offset</a></td><td class=SDescription>Returns the base offset of a memory location</td></tr>
  <!-- index=26 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_address" id=link24 onMouseOver="ShowTip(event, 'tt24', 'link24')" onMouseOut="HideTip('tt24')">get_address</a></td><td class=SDescription>Returns the base external physical address of a memory location</td></tr>
  <!-- index=27 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_addresses" id=link25 onMouseOver="ShowTip(event, 'tt25', 'link25')" onMouseOut="HideTip('tt25')">get_addresses</a></td><td class=SDescription>Identifies the external physical address(es) of a memory location</td></tr>
  <!-- index=28 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.HDL_Access" >HDL Access</a></td><td class=SDescription></td></tr>
  <!-- index=29 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.write" id=link26 onMouseOver="ShowTip(event, 'tt26', 'link26')" onMouseOut="HideTip('tt26')">write</a></td><td class=SDescription>Write the specified value in a memory location</td></tr>
  <!-- index=30 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.read" id=link27 onMouseOver="ShowTip(event, 'tt27', 'link27')" onMouseOut="HideTip('tt27')">read</a></td><td class=SDescription>Read the current value from a memory location</td></tr>
  <!-- index=31 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.burst_write" id=link28 onMouseOver="ShowTip(event, 'tt28', 'link28')" onMouseOut="HideTip('tt28')">burst_write</a></td><td class=SDescription>Write the specified values in memory locations</td></tr>
  <!-- index=32 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.burst_read" id=link29 onMouseOver="ShowTip(event, 'tt29', 'link29')" onMouseOut="HideTip('tt29')">burst_read</a></td><td class=SDescription>Read values from memory locations</td></tr>
  <!-- index=33 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.poke" id=link30 onMouseOver="ShowTip(event, 'tt30', 'link30')" onMouseOut="HideTip('tt30')">poke</a></td><td class=SDescription>Deposit the specified value in a memory location</td></tr>
  <!-- index=34 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.peek" id=link31 onMouseOver="ShowTip(event, 'tt31', 'link31')" onMouseOut="HideTip('tt31')">peek</a></td><td class=SDescription>Read the current value from a memory location</td></tr>
  <!-- index=35 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.Frontdoor" >Frontdoor</a></td><td class=SDescription></td></tr>
  <!-- index=36 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.set_frontdoor" id=link32 onMouseOver="ShowTip(event, 'tt32', 'link32')" onMouseOut="HideTip('tt32')">set_frontdoor</a></td><td class=SDescription>Set a user-defined frontdoor for this memory</td></tr>
  <!-- index=37 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_frontdoor" id=link33 onMouseOver="ShowTip(event, 'tt33', 'link33')" onMouseOut="HideTip('tt33')">get_frontdoor</a></td><td class=SDescription>Returns the user-defined frontdoor for this memory</td></tr>
  <!-- index=38 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.Backdoor" >Backdoor</a></td><td class=SDescription></td></tr>
  <!-- index=39 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.set_backdoor" id=link34 onMouseOver="ShowTip(event, 'tt34', 'link34')" onMouseOut="HideTip('tt34')">set_backdoor</a></td><td class=SDescription>Set a user-defined backdoor for this memory</td></tr>
  <!-- index=40 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_backdoor" id=link35 onMouseOver="ShowTip(event, 'tt35', 'link35')" onMouseOut="HideTip('tt35')">get_backdoor</a></td><td class=SDescription>Returns the user-defined backdoor for this memory</td></tr>
  <!-- index=41 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.clear_hdl_path" id=link36 onMouseOver="ShowTip(event, 'tt36', 'link36')" onMouseOut="HideTip('tt36')">clear_hdl_path</a></td><td class=SDescription>Delete HDL paths</td></tr>
  <!-- index=42 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.add_hdl_path" id=link37 onMouseOver="ShowTip(event, 'tt37', 'link37')" onMouseOut="HideTip('tt37')">add_hdl_path</a></td><td class=SDescription>Add an HDL path</td></tr>
  <!-- index=43 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.add_hdl_path_slice" id=link38 onMouseOver="ShowTip(event, 'tt38', 'link38')" onMouseOut="HideTip('tt38')">add_hdl_path_slice</a></td><td class=SDescription>Add the specified HDL slice to the HDL path for the specified design abstraction. </td></tr>
  <!-- index=44 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.has_hdl_path" id=link39 onMouseOver="ShowTip(event, 'tt39', 'link39')" onMouseOut="HideTip('tt39')">has_hdl_path</a></td><td class=SDescription>Check if a HDL path is specified</td></tr>
  <!-- index=45 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_hdl_path" id=link40 onMouseOver="ShowTip(event, 'tt40', 'link40')" onMouseOut="HideTip('tt40')">get_hdl_path</a></td><td class=SDescription>Get the incremental HDL path(s)</td></tr>
  <!-- index=46 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.get_full_hdl_path" id=link41 onMouseOver="ShowTip(event, 'tt41', 'link41')" onMouseOut="HideTip('tt41')">get_full_hdl_path</a></td><td class=SDescription>Get the full hierarchical HDL path(s)</td></tr>
  <!-- index=47 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_hdl_path_kinds" id=link42 onMouseOver="ShowTip(event, 'tt42', 'link42')" onMouseOut="HideTip('tt42')">get_hdl_path_kinds</a></td><td class=SDescription>Get design abstractions for which HDL paths have been defined</td></tr>
  <!-- index=48 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.backdoor_read" id=link43 onMouseOver="ShowTip(event, 'tt43', 'link43')" onMouseOut="HideTip('tt43')">backdoor_read</a></td><td class=SDescription>User-define backdoor read access</td></tr>
  <!-- index=49 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.backdoor_write" id=link44 onMouseOver="ShowTip(event, 'tt44', 'link44')" onMouseOut="HideTip('tt44')">backdoor_write</a></td><td class=SDescription>User-defined backdoor read access</td></tr>
  <!-- index=50 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.backdoor_read_func" id=link45 onMouseOver="ShowTip(event, 'tt45', 'link45')" onMouseOut="HideTip('tt45')">backdoor_read_func</a></td><td class=SDescription>User-defined backdoor read access</td></tr>
  <!-- index=51 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.Callbacks" >Callbacks</a></td><td class=SDescription></td></tr>
  <!-- index=52 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.pre_write" id=link46 onMouseOver="ShowTip(event, 'tt46', 'link46')" onMouseOut="HideTip('tt46')">pre_write</a></td><td class=SDescription>Called before memory write.</td></tr>
  <!-- index=53 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.post_write" id=link47 onMouseOver="ShowTip(event, 'tt47', 'link47')" onMouseOut="HideTip('tt47')">post_write</a></td><td class=SDescription>Called after memory write.</td></tr>
  <!-- index=54 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.pre_read" id=link48 onMouseOver="ShowTip(event, 'tt48', 'link48')" onMouseOut="HideTip('tt48')">pre_read</a></td><td class=SDescription>Called before memory read.</td></tr>
  <!-- index=55 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.post_read" id=link49 onMouseOver="ShowTip(event, 'tt49', 'link49')" onMouseOut="HideTip('tt49')">post_read</a></td><td class=SDescription>Called after memory read.</td></tr>
  <!-- index=56 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_mem.Coverage" >Coverage</a></td><td class=SDescription></td></tr>
  <!-- index=57 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.build_coverage" id=link50 onMouseOver="ShowTip(event, 'tt50', 'link50')" onMouseOut="HideTip('tt50')">build_coverage</a></td><td class=SDescription>Check if all of the specified coverage model must be built.</td></tr>
  <!-- index=58 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.add_coverage" id=link51 onMouseOver="ShowTip(event, 'tt51', 'link51')" onMouseOut="HideTip('tt51')">add_coverage</a></td><td class=SDescription>Specify that additional coverage models are available.</td></tr>
  <!-- index=59 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.has_coverage" id=link52 onMouseOver="ShowTip(event, 'tt52', 'link52')" onMouseOut="HideTip('tt52')">has_coverage</a></td><td class=SDescription>Check if memory has coverage model(s)</td></tr>
  <!-- index=60 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.set_coverage" id=link53 onMouseOver="ShowTip(event, 'tt53', 'link53')" onMouseOut="HideTip('tt53')">set_coverage</a></td><td class=SDescription>Turns on coverage measurement.</td></tr>
  <!-- index=61 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_mem.get_coverage" id=link54 onMouseOver="ShowTip(event, 'tt54', 'link54')" onMouseOut="HideTip('tt54')">get_coverage</a></td><td class=SDescription>Check if coverage measurement is on.</td></tr>
  <!-- index=62 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_mem.sample" id=link55 onMouseOver="ShowTip(event, 'tt55', 'link55')" onMouseOut="HideTip('tt55')">sample</a></td><td class=SDescription>Functional coverage measurement method</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Initialization" href="../../src/reg/uvm_mem.svh">Initialization</a></h3></div></div>




 <!--CONTENT index=2 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.new" href="../../src/reg/uvm_mem.svh">new</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function new (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>longint&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>size,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>n_bits,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>access</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RW&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>has_coverage</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_NO_COVERAGE</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Create a new instance and type-specific configuration</p><p>Creates an instance of a memory abstraction class with the specified name.</p><p><i>size</i> specifies the total number of memory locations.&nbsp; <i>n_bits</i> specifies the total number of bits in each memory location.&nbsp; <i>access</i> specifies the access policy of this memory and may be one of &ldquo;RW for RAMs and &ldquo;RO&rdquo; for ROMs.</p><p><i>has_coverage</i> specifies which functional coverage models are present in the extension of the register abstraction class.&nbsp; Multiple functional coverage models may be specified by adding their symbolic names, as defined by the <a href="uvm_reg_model-svh.html#uvm_coverage_model_e" class=LType id=link56 onMouseOver="ShowTip(event, 'tt56', 'link56')" onMouseOut="HideTip('tt56')">uvm_coverage_model_e</a> type.</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.configure" href="../../src/reg/uvm_mem.svh">configure</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void configure (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_block&nbsp;</td>
      <td class=PParameter nowrap>parent,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>hdl_path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Instance-specific configuration</p><p>Specify the parent block of this memory.</p><p>If this memory is implemented in a single HDL variable, its name is specified as the <i>hdl_path</i>.&nbsp; Otherwise, if the memory is implemented as a concatenation of variables (usually one per bank), then the HDL path must be specified using the <a href="#uvm_mem.add_hdl_path" class=LMethod id=link57 onMouseOver="ShowTip(event, 'tt37', 'link57')" onMouseOut="HideTip('tt37')">add_hdl_path()</a> or <a href="#uvm_mem.add_hdl_path_slice" class=LMethod id=link58 onMouseOver="ShowTip(event, 'tt38', 'link58')" onMouseOut="HideTip('tt38')">add_hdl_path_slice()</a> method.</p></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.set_offset" href="../../src/reg/uvm_mem.svh">set_offset</a></h3><div class=CBody><p>Modify the offset of the memory</p><p>The offset of a memory within an address map is set using the <a href="uvm_reg_map-svh.html#uvm_reg_map.add_mem" class=LMethod id=link59 onMouseOver="ShowTip(event, 'tt57', 'link59')" onMouseOut="HideTip('tt57')">uvm_reg_map::add_mem()</a> method.&nbsp; This method is used to modify that offset dynamically.</p></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Modifying_the_offset_of_a_memory_will_make_the_abstract_model" href="../../src/reg/uvm_mem.svh">Modifying the offset of a memory will make the abstract model</a></h3><div class=CBody><p>diverge from the specification that was used to create it.</p></div></div></div>




 <!--CONTENT index=6 -->
<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.mam" href="../../src/reg/uvm_mem.svh">mam</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>uvm_mem_mam mam
  </td></tr></table></blockquote><div class=CBody><p>Memory allocation manager</p><p>Memory allocation manager for the memory corresponding to this abstraction class instance.&nbsp; Can be used to allocate regions of consecutive addresses of specific sizes, such as DMA buffers, or to locate virtual register array.</p></div></div></div>




 <!--CONTENT index=7 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Introspection" href="../../src/reg/uvm_mem.svh">Introspection</a></h3></div></div>




 <!--CONTENT index=8 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_name" href="../../src/reg/uvm_mem.svh">get_name</a></h3><div class=CBody><p>Get the simple name</p><p>Return the simple object name of this memory.</p></div></div></div>




 <!--CONTENT index=9 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_full_name" href="../../src/reg/uvm_mem.svh">get_full_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_full_name()
  </td></tr></table></blockquote><div class=CBody><p>Get the hierarchical name</p><p>Return the hierarchal name of this memory.&nbsp; The base of the hierarchical name is the root block.</p></div></div></div>




 <!--CONTENT index=10 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_parent" href="../../src/reg/uvm_mem.svh">get_parent</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function uvm_reg_block get_parent ()
  </td></tr></table></blockquote><div class=CBody><p>Get the parent block</p></div></div></div>




 <!--CONTENT index=11 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_n_maps" href="../../src/reg/uvm_mem.svh">get_n_maps</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function int get_n_maps ()
  </td></tr></table></blockquote><div class=CBody><p>Returns the number of address maps this memory is mapped in</p></div></div></div>




 <!--CONTENT index=12 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.is_in_map" href="../../src/reg/uvm_mem.svh">is_in_map</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function bit is_in_map (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap width=100%>map</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Return TRUE if this memory is in the specified address <i>map</i></p></div></div></div>




 <!--CONTENT index=13 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_maps" href="../../src/reg/uvm_mem.svh">get_maps</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>virtual function void get_maps (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap width=100%>maps[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns all of the address <i>maps</i> where this memory is mapped</p></div></div></div>




 <!--CONTENT index=14 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_rights" href="../../src/reg/uvm_mem.svh">get_rights</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function string get_rights (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns the access rights of this memory.</p><p>Returns &ldquo;RW&rdquo;, &ldquo;RO&rdquo; or &ldquo;WO&rdquo;.&nbsp; The access rights of a memory is always &ldquo;RW&rdquo;, unless it is a shared memory with access restriction in a particular address map.</p><p>If no address map is specified and the memory is mapped in only one address map, that address map is used.&nbsp; If the memory is mapped in more than one address map, the default address map of the parent block is used.</p><p>If an address map is specified and the memory is not mapped in the specified address map, an error message is issued and &ldquo;RW&rdquo; is returned.</p></div></div></div>




 <!--CONTENT index=15 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_access" href="../../src/reg/uvm_mem.svh">get_access</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function string get_access(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns the access policy of the memory when written and read via an address map.</p><p>If the memory is mapped in more than one address map, an address <i>map</i> must be specified.&nbsp; If access restrictions are present when accessing a memory through the specified address map, the access mode returned takes the access restrictions into account.&nbsp; For example, a read-write memory accessed through a domain with read-only restrictions would return &ldquo;RO&rdquo;.</p></div></div></div>




 <!--CONTENT index=16 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_size" href="../../src/reg/uvm_mem.svh">get_size</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function longint unsigned get_size()
  </td></tr></table></blockquote><div class=CBody><p>Returns the number of unique memory locations in this memory.</p></div></div></div>




 <!--CONTENT index=17 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_n_bytes" href="../../src/reg/uvm_mem.svh">get_n_bytes</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int unsigned get_n_bytes()
  </td></tr></table></blockquote><div class=CBody><p>Return the width, in number of bytes, of each memory location</p></div></div></div>




 <!--CONTENT index=18 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_n_bits" href="../../src/reg/uvm_mem.svh">get_n_bits</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int unsigned get_n_bits()
  </td></tr></table></blockquote><div class=CBody><p>Returns the width, in number of bits, of each memory location</p></div></div></div>




 <!--CONTENT index=19 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_max_size" href="../../src/reg/uvm_mem.svh">get_max_size</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static function int unsigned get_max_size()
  </td></tr></table></blockquote><div class=CBody><p>Returns the maximum width, in number of bits, of all memories</p></div></div></div>




 <!--CONTENT index=20 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_virtual_registers" href="../../src/reg/uvm_mem.svh">get_virtual_registers</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>virtual function void get_virtual_registers(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_vreg&nbsp;</td>
      <td class=PParameter nowrap width=100%>regs[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Return the virtual registers in this memory</p><p>Fills the specified array with the abstraction class for all of the virtual registers implemented in this memory.&nbsp; The order in which the virtual registers are located in the array is not specified.</p></div></div></div>




 <!--CONTENT index=21 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_virtual_fields" href="../../src/reg/uvm_mem.svh">get_virtual_fields</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>virtual function void get_virtual_fields(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_vreg_field&nbsp;</td>
      <td class=PParameter nowrap width=100%>fields[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Return  the virtual fields in the memory</p><p>Fills the specified dynamic array with the abstraction class for all of the virtual fields implemented in this memory.&nbsp; The order in which the virtual fields are located in the array is not specified.</p></div></div></div>




 <!--CONTENT index=22 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_vreg_by_name" href="../../src/reg/uvm_mem.svh">get_vreg_by_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_vreg get_vreg_by_name(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Find the named virtual register</p><p>Finds a virtual register with the specified name implemented in this memory and returns its abstraction class instance.&nbsp; If no virtual register with the specified name is found, returns <i>null</i>.</p></div></div></div>




 <!--CONTENT index=23 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_vfield_by_name" href="../../src/reg/uvm_mem.svh">get_vfield_by_name</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_vreg_field get_vfield_by_name(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Find the named virtual field</p><p>Finds a virtual field with the specified name implemented in this memory and returns its abstraction class instance.&nbsp; If no virtual field with the specified name is found, returns <i>null</i>.</p></div></div></div>




 <!--CONTENT index=24 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_vreg_by_offset" href="../../src/reg/uvm_mem.svh">get_vreg_by_offset</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_vreg get_vreg_by_offset(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Find the virtual register implemented at the specified offset</p><p>Finds the virtual register implemented in this memory at the specified <i>offset</i> in the specified address <i>map</i> and returns its abstraction class instance.&nbsp; If no virtual register at the offset is found, returns <i>null</i>.</p></div></div></div>




 <!--CONTENT index=25 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_offset" href="../../src/reg/uvm_mem.svh">get_offset</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_reg_addr_t get_offset (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns the base offset of a memory location</p><p>Returns the base offset of the specified location in this memory in an address <i>map</i>.</p><p>If no address map is specified and the memory is mapped in only one address map, that address map is used.&nbsp; If the memory is mapped in more than one address map, the default address map of the parent block is used.</p><p>If an address map is specified and the memory is not mapped in the specified address map, an error message is issued.</p></div></div></div>




 <!--CONTENT index=26 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_address" href="../../src/reg/uvm_mem.svh">get_address</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_reg_addr_t get_address(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns the base external physical address of a memory location</p><p>Returns the base external physical address of the specified location in this memory if accessed through the specified address <i>map</i>.</p><p>If no address map is specified and the memory is mapped in only one address map, that address map is used.&nbsp; If the memory is mapped in more than one address map, the default address map of the parent block is used.</p><p>If an address map is specified and the memory is not mapped in the specified address map, an error message is issued.</p></div></div></div>




 <!--CONTENT index=27 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_addresses" href="../../src/reg/uvm_mem.svh">get_addresses</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual function int get_addresses(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>addr[]</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Identifies the external physical address(es) of a memory location</p><p>Computes all of the external physical addresses that must be accessed to completely read or write the specified location in this memory.&nbsp; The addressed are specified in little endian order.&nbsp; Returns the number of bytes transferred on each access.</p><p>If no address map is specified and the memory is mapped in only one address map, that address map is used.&nbsp; If the memory is mapped in more than one address map, the default address map of the parent block is used.</p><p>If an address map is specified and the memory is not mapped in the specified address map, an error message is issued.</p></div></div></div>




 <!--CONTENT index=28 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.HDL_Access" href="../../src/reg/uvm_mem.svh">HDL Access</a></h3></div></div>




 <!--CONTENT index=29 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.write" href="../../src/reg/uvm_mem.svh">write</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Write the specified value in a memory location</p><p>Write <i>value</i> in the memory location that corresponds to this abstraction class instance at the specified <i>offset</i> using the specified access <i>path</i>.&nbsp; If the memory is mapped in more than one address map, an address <i>map</i> must be specified if a physical access is used (front-door access).&nbsp; If a back-door access path is used, the effect of writing the register through a physical access is mimicked.&nbsp; For example, a read-only memory will not be written.</p></div></div></div>




 <!--CONTENT index=30 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.read" href="../../src/reg/uvm_mem.svh">read</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Read the current value from a memory location</p><p>Read and return <i>value</i> from the memory location that corresponds to this abstraction class instance at the specified <i>offset</i> using the specified access <i>path</i>.&nbsp; If the register is mapped in more than one address map, an address <i>map</i> must be specified if a physical access is used (front-door access).</p></div></div></div>




 <!--CONTENT index=31 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.burst_write" href="../../src/reg/uvm_mem.svh">burst_write</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task burst_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Write the specified values in memory locations</p><p>Burst-write the specified <i>values</i> in the memory locations beginning at the specified <i>offset</i>.&nbsp; If the memory is mapped in more than one address map, an address <i>map</i> must be specified if not using the backdoor.&nbsp; If a back-door access path is used, the effect of writing the register through a physical access is mimicked.&nbsp; For example, a read-only memory will not be written.</p></div></div></div>




 <!--CONTENT index=32 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.burst_read" href="../../src/reg/uvm_mem.svh">burst_read</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task burst_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Read values from memory locations</p><p>Burst-read into <i>values</i> the data the memory locations beginning at the specified <i>offset</i>.&nbsp; If the memory is mapped in more than one address map, an address <i>map</i> must be specified if not using the backdoor.&nbsp; If a back-door access path is used, the effect of writing the register through a physical access is mimicked.&nbsp; For example, a read-only memory will not be written.</p></div></div></div>




 <!--CONTENT index=33 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.poke" href="../../src/reg/uvm_mem.svh">poke</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task poke(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Deposit the specified value in a memory location</p><p>Deposit the value in the DUT memory location corresponding to this abstraction class instance at the specified <i>offset</i>, as-is, using a back-door access.</p><p>Uses the HDL path for the design abstraction specified by <i>kind</i>.</p></div></div></div>




 <!--CONTENT index=34 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.peek" href="../../src/reg/uvm_mem.svh">peek</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task peek(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Read the current value from a memory location</p><p>Sample the value in the DUT memory location corresponding to this abstraction class instance at the specified <i>offset</i> using a back-door access.&nbsp; The memory location value is sampled, not modified.</p><p>Uses the HDL path for the design abstraction specified by <i>kind</i>.</p></div></div></div>




 <!--CONTENT index=35 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Frontdoor" href="../../src/reg/uvm_mem.svh">Frontdoor</a></h3></div></div>




 <!--CONTENT index=36 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.set_frontdoor" href="../../src/reg/uvm_mem.svh">set_frontdoor</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void set_frontdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_frontdoor&nbsp;</td>
      <td class=PParameter nowrap>ftdr,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Set a user-defined frontdoor for this memory</p><p>By default, memories are mapped linearly into the address space of the address maps that instantiate them.&nbsp; If memories are accessed using a different mechanism, a user-defined access mechanism must be defined and associated with the corresponding memory abstraction class</p><p>If the memory is mapped in multiple address maps, an address <i>map</i> must be specified.</p></div></div></div>




 <!--CONTENT index=37 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_frontdoor" href="../../src/reg/uvm_mem.svh">get_frontdoor</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function uvm_reg_frontdoor get_frontdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns the user-defined frontdoor for this memory</p><p>If <i>null</i>, no user-defined frontdoor has been defined.&nbsp; A user-defined frontdoor is defined by using the <a href="#uvm_mem.set_frontdoor" class=LMethod id=link60 onMouseOver="ShowTip(event, 'tt32', 'link60')" onMouseOut="HideTip('tt32')">uvm_mem::set_frontdoor()</a> method.</p><p>If the memory is mapped in multiple address maps, an address <i>map</i> must be specified.</p></div></div></div>




 <!--CONTENT index=38 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Backdoor" href="../../src/reg/uvm_mem.svh">Backdoor</a></h3></div></div>




 <!--CONTENT index=39 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.set_backdoor" href="../../src/reg/uvm_mem.svh">set_backdoor</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void set_backdoor (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_backdoor&nbsp;</td>
      <td class=PParameter nowrap>bkdr,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Set a user-defined backdoor for this memory</p><p>By default, memories are accessed via the built-in string-based DPI routines if an HDL path has been specified using the <a href="#uvm_mem.configure" class=LMethod id=link61 onMouseOver="ShowTip(event, 'tt5', 'link61')" onMouseOut="HideTip('tt5')">uvm_mem::configure()</a> or <a href="#uvm_mem.add_hdl_path" class=LMethod id=link62 onMouseOver="ShowTip(event, 'tt37', 'link62')" onMouseOut="HideTip('tt37')">uvm_mem::add_hdl_path()</a> method.&nbsp; If this default mechanism is not suitable (e.g. because the memory is not implemented in pure SystemVerilog) a user-defined access mechanism must be defined and associated with the corresponding memory abstraction class</p></div></div></div>




 <!--CONTENT index=40 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_backdoor" href="../../src/reg/uvm_mem.svh">get_backdoor</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function uvm_reg_backdoor get_backdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>inherited</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Returns the user-defined backdoor for this memory</p><p>If <i>null</i>, no user-defined backdoor has been defined.&nbsp; A user-defined backdoor is defined by using the <a href="uvm_reg-svh.html#uvm_reg.set_backdoor" class=LMethod id=link63 onMouseOver="ShowTip(event, 'tt58', 'link63')" onMouseOut="HideTip('tt58')">uvm_reg::set_backdoor()</a> method.</p><p>If <i>inherit</i> is TRUE, returns the backdoor of the parent block if none have been specified for this memory.</p></div></div></div>




 <!--CONTENT index=41 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.clear_hdl_path" href="../../src/reg/uvm_mem.svh">clear_hdl_path</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void clear_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RTL&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Delete HDL paths</p><p>Remove any previously specified HDL path to the memory instance for the specified design abstraction.</p></div></div></div>




 <!--CONTENT index=42 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.add_hdl_path" href="../../src/reg/uvm_mem.svh">add_hdl_path</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void add_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_hdl_path_slice&nbsp;</td>
      <td class=PParameter nowrap>slices[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RTL&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Add an HDL path</p><p>Add the specified HDL path to the memory instance for the specified design abstraction.&nbsp; This method may be called more than once for the same design abstraction if the memory is physically duplicated in the design abstraction</p></div></div></div>




 <!--CONTENT index=43 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.add_hdl_path_slice" href="../../src/reg/uvm_mem.svh">add_hdl_path_slice</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void add_hdl_path_slice(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>size,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>first</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RTL&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Add the specified HDL slice to the HDL path for the specified design abstraction.&nbsp; If <i>first</i> is TRUE, starts the specification of a duplicate HDL implementation of the memory.</p></div></div></div>




 <!--CONTENT index=44 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.has_hdl_path" href="../../src/reg/uvm_mem.svh">has_hdl_path</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function bit has_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Check if a HDL path is specified</p><p>Returns TRUE if the memory instance has a HDL path defined for the specified design abstraction.&nbsp; If no design abstraction is specified, uses the default design abstraction specified for the parent block.</p></div></div></div>




 <!--CONTENT index=45 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_hdl_path" href="../../src/reg/uvm_mem.svh">get_hdl_path</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function void get_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_hdl_path_concat&nbsp;</td>
      <td class=PParameter nowrap>paths[$],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Get the incremental HDL path(s)</p><p>Returns the HDL path(s) defined for the specified design abstraction in the memory instance.&nbsp; Returns only the component of the HDL paths that corresponds to the memory, not a full hierarchical path</p><p>If no design abstraction is specified, the default design abstraction for the parent block is used.</p></div></div></div>




 <!--CONTENT index=46 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_full_hdl_path" href="../../src/reg/uvm_mem.svh">get_full_hdl_path</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function void get_full_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_hdl_path_concat&nbsp;</td>
      <td class=PParameter nowrap>paths[$],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>separator</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;.&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Get the full hierarchical HDL path(s)</p><p>Returns the full hierarchical HDL path(s) defined for the specified design abstraction in the memory instance.&nbsp; There may be more than one path returned even if only one path was defined for the memory instance, if any of the parent components have more than one path defined for the same design abstraction</p><p>If no design abstraction is specified, the default design abstraction for each ancestor block is used to get each incremental path.</p></div></div></div>




 <!--CONTENT index=47 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_hdl_path_kinds" href="../../src/reg/uvm_mem.svh">get_hdl_path_kinds</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>function void get_hdl_path_kinds (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>kinds[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Get design abstractions for which HDL paths have been defined</p></div></div></div>




 <!--CONTENT index=48 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.backdoor_read" href="../../src/reg/uvm_mem.svh">backdoor_read</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual protected task backdoor_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>User-define backdoor read access</p><p>Override the default string-based DPI backdoor access read for this memory type.&nbsp; By default calls <a href="#uvm_mem.backdoor_read_func" class=LMethod id=link64 onMouseOver="ShowTip(event, 'tt45', 'link64')" onMouseOut="HideTip('tt45')">uvm_mem::backdoor_read_func()</a>.</p></div></div></div>




 <!--CONTENT index=49 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.backdoor_write" href="../../src/reg/uvm_mem.svh">backdoor_write</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task backdoor_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>User-defined backdoor read access</p><p>Override the default string-based DPI backdoor access write for this memory type.</p></div></div></div>




 <!--CONTENT index=50 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.backdoor_read_func" href="../../src/reg/uvm_mem.svh">backdoor_read_func</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_status_e backdoor_read_func(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>User-defined backdoor read access</p><p>Override the default string-based DPI backdoor access read for this memory type.</p></div></div></div>




 <!--CONTENT index=51 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Callbacks" href="../../src/reg/uvm_mem.svh">Callbacks</a></h3></div></div>




 <!--CONTENT index=52 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.pre_write" href="../../src/reg/uvm_mem.svh">pre_write</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task pre_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Called before memory write.</p><p>If the <i>offset</i>, <i>value</i>, access <i>path</i>, or address <i>map</i> are modified, the updated offset, data value, access path or address map will be used to perform the memory operation.&nbsp; If the <i>status</i> is modified to anything other than <a href="uvm_reg_model-svh.html#UVM_IS_OK" class=LConstant id=link65 onMouseOver="ShowTip(event, 'tt59', 'link65')" onMouseOut="HideTip('tt59')">UVM_IS_OK</a>, the operation is aborted.</p><p>The registered callback methods are invoked after the invocation of this method.</p></div></div></div>




 <!--CONTENT index=53 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.post_write" href="../../src/reg/uvm_mem.svh">post_write</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task post_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Called after memory write.</p><p>If the <i>status</i> is modified, the updated status will be returned by the memory operation.</p><p>The registered callback methods are invoked before the invocation of this method.</p></div></div></div>




 <!--CONTENT index=54 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.pre_read" href="../../src/reg/uvm_mem.svh">pre_read</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task pre_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Called before memory read.</p><p>If the <i>offset</i>, access <i>path</i> or address <i>map</i> are modified, the updated offset, access path or address map will be used to perform the memory operation.&nbsp; If the <i>status</i> is modified to anything other than <a href="uvm_reg_model-svh.html#UVM_IS_OK" class=LConstant id=link66 onMouseOver="ShowTip(event, 'tt59', 'link66')" onMouseOut="HideTip('tt59')">UVM_IS_OK</a>, the operation is aborted.</p><p>The registered callback methods are invoked after the invocation of this method.</p></div></div></div>




 <!--CONTENT index=55 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.post_read" href="../../src/reg/uvm_mem.svh">post_read</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task post_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Called after memory read.</p><p>If the readback data or <i>status</i> is modified, the updated readback //data or status will be returned by the memory operation.</p><p>The registered callback methods are invoked before the invocation of this method.</p></div></div></div>




 <!--CONTENT index=56 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.Coverage" href="../../src/reg/uvm_mem.svh">Coverage</a></h3></div></div>




 <!--CONTENT index=57 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.build_coverage" href="../../src/reg/uvm_mem.svh">build_coverage</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>protected function uvm_reg_cvr_t build_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>models</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Check if all of the specified coverage model must be built.</p><p>Check which of the specified coverage model must be built in this instance of the memory abstraction class, as specified by calls to <a href="uvm_reg-svh.html#uvm_reg.include_coverage" class=LMethod id=link67 onMouseOver="ShowTip(event, 'tt60', 'link67')" onMouseOut="HideTip('tt60')">uvm_reg::include_coverage()</a>.</p><p>Models are specified by adding the symbolic value of individual coverage model as defined in <a href="uvm_reg_model-svh.html#uvm_coverage_model_e" class=LType id=link68 onMouseOver="ShowTip(event, 'tt56', 'link68')" onMouseOut="HideTip('tt56')">uvm_coverage_model_e</a>.&nbsp; Returns the sum of all coverage models to be built in the memory model.</p></div></div></div>




 <!--CONTENT index=58 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.add_coverage" href="../../src/reg/uvm_mem.svh">add_coverage</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual protected function void add_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>models</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Specify that additional coverage models are available.</p><p>Add the specified coverage model to the coverage models available in this class.&nbsp; Models are specified by adding the symbolic value of individual coverage model as defined in <a href="uvm_reg_model-svh.html#uvm_coverage_model_e" class=LType id=link69 onMouseOver="ShowTip(event, 'tt56', 'link69')" onMouseOut="HideTip('tt56')">uvm_coverage_model_e</a>.</p><p>This method shall be called only in the constructor of subsequently derived classes.</p></div></div></div>




 <!--CONTENT index=59 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.has_coverage" href="../../src/reg/uvm_mem.svh">has_coverage</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function bit has_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>models</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Check if memory has coverage model(s)</p><p>Returns TRUE if the memory abstraction class contains a coverage model for all of the models specified.&nbsp; Models are specified by adding the symbolic value of individual coverage model as defined in <a href="uvm_reg_model-svh.html#uvm_coverage_model_e" class=LType id=link70 onMouseOver="ShowTip(event, 'tt56', 'link70')" onMouseOut="HideTip('tt56')">uvm_coverage_model_e</a>.</p></div></div></div>




 <!--CONTENT index=60 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.set_coverage" href="../../src/reg/uvm_mem.svh">set_coverage</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_reg_cvr_t set_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_on</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Turns on coverage measurement.</p><p>Turns the collection of functional coverage measurements on or off for this memory.&nbsp; The functional coverage measurement is turned on for every coverage model specified using <a href="uvm_reg_model-svh.html#uvm_coverage_model_e" class=LType id=link71 onMouseOver="ShowTip(event, 'tt56', 'link71')" onMouseOut="HideTip('tt56')">uvm_coverage_model_e</a> symbolic identifiers.&nbsp; Multiple functional coverage models can be specified by adding the functional coverage model identifiers.&nbsp; All other functional coverage models are turned off.&nbsp; Returns the sum of all functional coverage models whose measurements were previously on.</p><p>This method can only control the measurement of functional coverage models that are present in the memory abstraction classes, then enabled during construction.&nbsp; See the <a href="#uvm_mem.has_coverage" class=LMethod id=link72 onMouseOver="ShowTip(event, 'tt52', 'link72')" onMouseOut="HideTip('tt52')">uvm_mem::has_coverage()</a> method to identify the available functional coverage models.</p></div></div></div>




 <!--CONTENT index=61 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.get_coverage" href="../../src/reg/uvm_mem.svh">get_coverage</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function bit get_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_on</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Check if coverage measurement is on.</p><p>Returns TRUE if measurement for all of the specified functional coverage models are currently on.&nbsp; Multiple functional coverage models can be specified by adding the functional coverage model identifiers.</p><p>See <a href="#uvm_mem.set_coverage" class=LMethod id=link73 onMouseOver="ShowTip(event, 'tt53', 'link73')" onMouseOut="HideTip('tt53')">uvm_mem::set_coverage()</a> for more details.</p></div></div></div>




 <!--CONTENT index=62 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_mem.sample" href="../../src/reg/uvm_mem.svh">sample</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>protected virtual function void sample(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>offset,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_read,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap width=100%>map</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Functional coverage measurement method</p><p>This method is invoked by the memory abstraction class whenever an address within one of its address map is successfully read or written.&nbsp; The specified offset is the offset within the memory, not an absolute address.</p><p>Empty by default, this method may be extended by the abstraction class generator to perform the required sampling in any provided functional coverage model.</p></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_void
  </td></tr></table></blockquote>The <i>uvm_void</i> class is the base class for all UVM classes. </div></div><div class=CToolTip id="tt2"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_object extends uvm_void
  </td></tr></table></blockquote>The uvm_object class is the base class for all UVM data and hierarchical classes. </div></div><div class=CToolTip id="tt3"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_mem extends uvm_object
  </td></tr></table></blockquote>Memory abstraction base class</div></div><div class=CToolTip id="tt4"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function new (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>longint&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>size,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap>n_bits,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>access</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RW&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>has_coverage</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_NO_COVERAGE</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Create a new instance and type-specific configuration</div></div><div class=CToolTip id="tt5"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void configure (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_block&nbsp;</td>
      <td class=PParameter nowrap>parent,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>hdl_path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Instance-specific configuration</div></div><div class=CToolTip id="tt6"><div class=CVariable>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>uvm_mem_mam mam
  </td></tr></table></blockquote>Memory allocation manager</div></div><div class=CToolTip id="tt7"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function string get_full_name()
  </td></tr></table></blockquote>Get the hierarchical name</div></div><div class=CToolTip id="tt8"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function uvm_reg_block get_parent ()
  </td></tr></table></blockquote>Get the parent block</div></div><div class=CToolTip id="tt9"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function int get_n_maps ()
  </td></tr></table></blockquote>Returns the number of address maps this memory is mapped in</div></div><div class=CToolTip id="tt10"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function bit is_in_map (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap width=100%>map</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Return TRUE if this memory is in the specified address <i>map</i></div></div><div class=CToolTip id="tt11"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>virtual function void get_maps (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap width=100%>maps[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns all of the address <i>maps</i> where this memory is mapped</div></div><div class=CToolTip id="tt12"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function string get_rights (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns the access rights of this memory.</div></div><div class=CToolTip id="tt13"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function string get_access(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns the access policy of the memory when written and read via an address map.</div></div><div class=CToolTip id="tt14"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function longint unsigned get_size()
  </td></tr></table></blockquote>Returns the number of unique memory locations in this memory.</div></div><div class=CToolTip id="tt15"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int unsigned get_n_bytes()
  </td></tr></table></blockquote>Return the width, in number of bytes, of each memory location</div></div><div class=CToolTip id="tt16"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int unsigned get_n_bits()
  </td></tr></table></blockquote>Returns the width, in number of bits, of each memory location</div></div><div class=CToolTip id="tt17"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>static function int unsigned get_max_size()
  </td></tr></table></blockquote>Returns the maximum width, in number of bits, of all memories</div></div><div class=CToolTip id="tt18"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>virtual function void get_virtual_registers(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_vreg&nbsp;</td>
      <td class=PParameter nowrap width=100%>regs[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Return the virtual registers in this memory</div></div><div class=CToolTip id="tt19"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>virtual function void get_virtual_fields(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_vreg_field&nbsp;</td>
      <td class=PParameter nowrap width=100%>fields[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Return  the virtual fields in the memory</div></div><div class=CToolTip id="tt20"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_vreg get_vreg_by_name(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Find the named virtual register</div></div><div class=CToolTip id="tt21"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_vreg_field get_vfield_by_name(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Find the named virtual field</div></div><div class=CToolTip id="tt22"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_vreg get_vreg_by_offset(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Find the virtual register implemented at the specified offset</div></div><div class=CToolTip id="tt23"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_reg_addr_t get_offset (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns the base offset of a memory location</div></div><div class=CToolTip id="tt24"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function uvm_reg_addr_t get_address(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns the base external physical address of a memory location</div></div><div class=CToolTip id="tt25"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual function int get_addresses(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap></td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>addr[]</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Identifies the external physical address(es) of a memory location</div></div><div class=CToolTip id="tt26"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Write the specified value in a memory location</div></div><div class=CToolTip id="tt27"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Read the current value from a memory location</div></div><div class=CToolTip id="tt28"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task burst_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Write the specified values in memory locations</div></div><div class=CToolTip id="tt29"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task burst_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_path_e&nbsp;</td>
      <td class=PParameter nowrap>path</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> UVM_DEFAULT_PATH,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>prior</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Read values from memory locations</div></div><div class=CToolTip id="tt30"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task poke(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Deposit the specified value in a memory location</div></div><div class=CToolTip id="tt31"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>virtual task peek(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_status_e&nbsp;</td>
      <td class=PParameter nowrap>status,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>output&nbsp;</td>
      <td class=PType nowrap>uvm_reg_data_t&nbsp;</td>
      <td class=PParameter nowrap>value,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>extension</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Read the current value from a memory location</div></div><div class=CToolTip id="tt32"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void set_frontdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_frontdoor&nbsp;</td>
      <td class=PParameter nowrap>ftdr,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Set a user-defined frontdoor for this memory</div></div><div class=CToolTip id="tt33"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function uvm_reg_frontdoor get_frontdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap>map</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns the user-defined frontdoor for this memory</div></div><div class=CToolTip id="tt34"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void set_backdoor (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_backdoor&nbsp;</td>
      <td class=PParameter nowrap>bkdr,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Set a user-defined backdoor for this memory</div></div><div class=CToolTip id="tt35"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function uvm_reg_backdoor get_backdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>inherited</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Returns the user-defined backdoor for this memory</div></div><div class=CToolTip id="tt36"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void clear_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RTL&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Delete HDL paths</div></div><div class=CToolTip id="tt37"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void add_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_hdl_path_slice&nbsp;</td>
      <td class=PParameter nowrap>slices[],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RTL&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Add an HDL path</div></div><div class=CToolTip id="tt38"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void add_hdl_path_slice(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>size,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>first</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RTL&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Add the specified HDL slice to the HDL path for the specified design abstraction. </div></div><div class=CToolTip id="tt39"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function bit has_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Check if a HDL path is specified</div></div><div class=CToolTip id="tt40"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function void get_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_hdl_path_concat&nbsp;</td>
      <td class=PParameter nowrap>paths[$],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Get the incremental HDL path(s)</div></div><div class=CToolTip id="tt41"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=6>function void get_full_hdl_path (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>uvm_hdl_path_concat&nbsp;</td>
      <td class=PParameter nowrap>paths[$],</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>kind</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>input&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>separator</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;.&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=6>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Get the full hierarchical HDL path(s)</div></div><div class=CToolTip id="tt42"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>function void get_hdl_path_kinds (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>ref&nbsp;</td>
      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>kinds[$]</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Get design abstractions for which HDL paths have been defined</div></div><div class=CToolTip id="tt43"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual protected task backdoor_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
User-define backdoor read access</div></div><div class=CToolTip id="tt44"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task backdoor_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
User-defined backdoor read access</div></div><div class=CToolTip id="tt45"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_status_e backdoor_read_func(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
User-defined backdoor read access</div></div><div class=CToolTip id="tt46"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task pre_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Called before memory write.</div></div><div class=CToolTip id="tt47"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task post_write(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Called after memory write.</div></div><div class=CToolTip id="tt48"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task pre_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Called before memory read.</div></div><div class=CToolTip id="tt49"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task post_read(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>rw</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Called after memory read.</div></div><div class=CToolTip id="tt50"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>protected function uvm_reg_cvr_t build_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>models</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Check if all of the specified coverage model must be built.</div></div><div class=CToolTip id="tt51"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual protected function void add_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>models</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Specify that additional coverage models are available.</div></div><div class=CToolTip id="tt52"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function bit has_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>models</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Check if memory has coverage model(s)</div></div><div class=CToolTip id="tt53"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function uvm_reg_cvr_t set_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_on</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Turns on coverage measurement.</div></div><div class=CToolTip id="tt54"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function bit get_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_on</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Check if coverage measurement is on.</div></div><div class=CToolTip id="tt55"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>protected virtual function void sample(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap width=100%>offset,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_read,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_map&nbsp;</td>
      <td class=PParameter nowrap width=100%>map</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Functional coverage measurement method</div></div><div class=CToolTip id="tt56"><div class=CType>Coverage models available or desired. </div></div><div class=CToolTip id="tt57"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void add_mem (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_mem&nbsp;</td>
      <td class=PParameter nowrap>mem,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_addr_t&nbsp;</td>
      <td class=PParameter nowrap>offset,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>rights</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;RW&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>unmapped</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_frontdoor&nbsp;</td>
      <td class=PParameter nowrap>frontdoor</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Add a memory</div></div><div class=CToolTip id="tt58"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void set_backdoor(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_backdoor&nbsp;</td>
      <td class=PParameter nowrap>bkdr,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>fname</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>lineno</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Set a user-defined backdoor for this register</div></div><div class=CToolTip id="tt59"><div class=CConstant>Operation completed successfully</div></div><div class=CToolTip id="tt60"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>static function void include_coverage(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>scope,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_reg_cvr_t&nbsp;</td>
      <td class=PParameter nowrap>models,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object&nbsp;</td>
      <td class=PParameter nowrap>accessor</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Specify which coverage model that must be included in various block, register or memory abstraction class instances.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>