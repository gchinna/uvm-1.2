<html><head><title>uvm_sequence_base</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script language=JavaScript src="../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CClass"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="uvm_sequence_base" href="../../src/seq/uvm_sequence_base.svh">uvm_sequence_base</a></h1><div class=CBody><p>The uvm_sequence_base class provides the interfaces needed to create streams of sequence items and/or other sequences.</p><p>A sequence is executed by calling its <a href="#uvm_sequence_base.start" class=LMethod id=link58 onMouseOver="ShowTip(event, 'tt12', 'link58')" onMouseOut="HideTip('tt12')">start</a> method, either directly or invocation of any of the `uvm_do_* macros.</p><h4 class=CHeading>Executing sequences via <a href="#uvm_sequence_base.start" class=LMethod id=link59 onMouseOver="ShowTip(event, 'tt12', 'link59')" onMouseOut="HideTip('tt12')">start</a></h4><p>A sequence&rsquo;s <a href="#uvm_sequence_base.start" class=LMethod id=link60 onMouseOver="ShowTip(event, 'tt12', 'link60')" onMouseOut="HideTip('tt12')">start</a> method has a <i>parent_sequence</i> argument that controls whether <a href="#uvm_sequence_base.pre_do" class=LMethod id=link61 onMouseOver="ShowTip(event, 'tt16', 'link61')" onMouseOut="HideTip('tt16')">pre_do</a>, <a href="#uvm_sequence_base.mid_do" class=LMethod id=link62 onMouseOver="ShowTip(event, 'tt17', 'link62')" onMouseOut="HideTip('tt17')">mid_do</a>, and <a href="#uvm_sequence_base.post_do" class=LMethod id=link63 onMouseOver="ShowTip(event, 'tt18', 'link63')" onMouseOut="HideTip('tt18')">post_do</a> are called <b>in the parent</b> sequence.&nbsp; It also has a <i>call_pre_post</i> argument that controls whether its <a href="#uvm_sequence_base.pre_body" class=LMethod id=link64 onMouseOver="ShowTip(event, 'tt14', 'link64')" onMouseOut="HideTip('tt14')">pre_body</a> and <a href="#uvm_sequence_base.post_body" class=LMethod id=link65 onMouseOver="ShowTip(event, 'tt19', 'link65')" onMouseOut="HideTip('tt19')">post_body</a> methods are called.&nbsp; In all cases, its <a href="#uvm_sequence_base.pre_start" class=LMethod id=link66 onMouseOver="ShowTip(event, 'tt13', 'link66')" onMouseOut="HideTip('tt13')">pre_start</a> and <a href="#uvm_sequence_base.post_start" class=LMethod id=link67 onMouseOver="ShowTip(event, 'tt20', 'link67')" onMouseOut="HideTip('tt20')">post_start</a> methods are always called.</p><p>When <a href="#uvm_sequence_base.start" class=LMethod id=link68 onMouseOver="ShowTip(event, 'tt12', 'link68')" onMouseOut="HideTip('tt12')">start</a> is called directly, you can provide the appropriate arguments according to your application.</p><p>The sequence execution flow looks like this</p><p>User code</p><blockquote><pre>sub_seq.randomize(...); // optional
sub_seq.start(seqr, parent_seq, priority, call_pre_post)</pre></blockquote><p>The following methods are called, in order</p><blockquote><pre>sub_seq.pre_start()        (task)
sub_seq.pre_body()         (task)  if call_pre_post==1
  parent_seq.pre_do(0)     (task)  if parent_sequence!=null
  parent_seq.mid_do(this)  (func)  if parent_sequence!=null
sub_seq.body               (task)  YOUR STIMULUS CODE
  parent_seq.post_do(this) (func)  if parent_sequence!=null
sub_seq.post_body()        (task)  if call_pre_post==1
sub_seq.post_start()       (task)</pre></blockquote><h4 class=CHeading>Executing sub-sequences via `uvm_do macros</h4><p>A sequence can also be indirectly started as a child in the <a href="#uvm_sequence_base.body" class=LMethod id=link69 onMouseOver="ShowTip(event, 'tt15', 'link69')" onMouseOut="HideTip('tt15')">body</a> of a parent sequence.&nbsp; The child sequence&rsquo;s <a href="#uvm_sequence_base.start" class=LMethod id=link70 onMouseOver="ShowTip(event, 'tt12', 'link70')" onMouseOut="HideTip('tt12')">start</a> method is called indirectly by invoking any of the `uvm_do macros.&nbsp; In these cases, <a href="#uvm_sequence_base.start" class=LMethod id=link71 onMouseOver="ShowTip(event, 'tt12', 'link71')" onMouseOut="HideTip('tt12')">start</a> is called with <i>call_pre_post</i> set to 0, preventing the started sequence&rsquo;s <a href="#uvm_sequence_base.pre_body" class=LMethod id=link72 onMouseOver="ShowTip(event, 'tt14', 'link72')" onMouseOut="HideTip('tt14')">pre_body</a> and <a href="#uvm_sequence_base.post_body" class=LMethod id=link73 onMouseOver="ShowTip(event, 'tt19', 'link73')" onMouseOut="HideTip('tt19')">post_body</a> methods from being called.&nbsp; During execution of the child sequence, the parent&rsquo;s <a href="#uvm_sequence_base.pre_do" class=LMethod id=link74 onMouseOver="ShowTip(event, 'tt16', 'link74')" onMouseOut="HideTip('tt16')">pre_do</a>, <a href="#uvm_sequence_base.mid_do" class=LMethod id=link75 onMouseOver="ShowTip(event, 'tt17', 'link75')" onMouseOut="HideTip('tt17')">mid_do</a>, and <a href="#uvm_sequence_base.post_do" class=LMethod id=link76 onMouseOver="ShowTip(event, 'tt18', 'link76')" onMouseOut="HideTip('tt18')">post_do</a> methods are called.</p><p>The sub-sequence execution flow looks like</p><p>User code</p><blockquote><pre>`uvm_do_with_prior(seq_seq, { constraints }, priority)</pre></blockquote><p>The following methods are called, in order</p><blockquote><pre>sub_seq.pre_start()         (task)
parent_seq.pre_do(0)        (task)
parent_req.mid_do(sub_seq)  (func)
  sub_seq.body()            (task)
parent_seq.post_do(sub_seq) (func)
sub_seq.post_start()        (task)</pre></blockquote><p>Remember, it is the <b>parent</b> sequence&rsquo;s pre|mid|post_do that are called, not the sequence being executed.</p><h4 class=CHeading>Executing sequence items via <a href="#uvm_sequence_base.start_item" class=LMethod id=link77 onMouseOver="ShowTip(event, 'tt38', 'link77')" onMouseOut="HideTip('tt38')">start_item</a>/<a href="#uvm_sequence_base.finish_item" class=LMethod id=link78 onMouseOver="ShowTip(event, 'tt39', 'link78')" onMouseOut="HideTip('tt39')">finish_item</a> or `uvm_do macros</h4><p>Items are started in the <a href="#uvm_sequence_base.body" class=LMethod id=link79 onMouseOver="ShowTip(event, 'tt15', 'link79')" onMouseOut="HideTip('tt15')">body</a> of a parent sequence via calls to <a href="#uvm_sequence_base.start_item" class=LMethod id=link80 onMouseOver="ShowTip(event, 'tt38', 'link80')" onMouseOut="HideTip('tt38')">start_item</a>/<a href="#uvm_sequence_base.finish_item" class=LMethod id=link81 onMouseOver="ShowTip(event, 'tt39', 'link81')" onMouseOut="HideTip('tt39')">finish_item</a> or invocations of any of the `uvm_do macros.&nbsp; The <a href="#uvm_sequence_base.pre_do" class=LMethod id=link82 onMouseOver="ShowTip(event, 'tt16', 'link82')" onMouseOut="HideTip('tt16')">pre_do</a>, <a href="#uvm_sequence_base.mid_do" class=LMethod id=link83 onMouseOver="ShowTip(event, 'tt17', 'link83')" onMouseOut="HideTip('tt17')">mid_do</a>, and <a href="#uvm_sequence_base.post_do" class=LMethod id=link84 onMouseOver="ShowTip(event, 'tt18', 'link84')" onMouseOut="HideTip('tt18')">post_do</a> methods of the parent sequence will be called as the item is executed.</p><p>The sequence-item execution flow looks like</p><p>User code</p><blockquote><pre>parent_seq.start_item(item, priority);
item.randomize(...) [with {constraints}];
parent_seq.finish_item(item);

or

`uvm_do_with_prior(item, constraints, priority)</pre></blockquote><p>The following methods are called, in order</p><blockquote><pre>sequencer.wait_for_grant(prior) (task) \ start_item  \
parent_seq.pre_do(1)            (task) /              \
                                                   `uvm_do* macros
parent_seq.mid_do(item)         (func) \              /
sequencer.send_request(item)    (func)  \finish_item /
sequencer.wait_for_item_done()  (task)  /
parent_seq.post_do(item)        (func) /</pre></blockquote><p>Attempting to execute a sequence via <a href="#uvm_sequence_base.start_item" class=LMethod id=link85 onMouseOver="ShowTip(event, 'tt38', 'link85')" onMouseOut="HideTip('tt38')">start_item</a>/<a href="#uvm_sequence_base.finish_item" class=LMethod id=link86 onMouseOver="ShowTip(event, 'tt39', 'link86')" onMouseOut="HideTip('tt39')">finish_item</a> will produce a run-time error.</p>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SClass"><td colspan=2 class=SEntry><a href="#uvm_sequence_base" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">uvm_sequence_base</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>The uvm_sequence_base class provides the interfaces needed to create streams of sequence items and/or other sequences.</td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry><a href="../base/uvm_misc-svh.html#uvm_void" class=LClass id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">uvm_void</a></div></div></td></tr>
          <tr><td><div class=CHParent><div class=CHEntry><a href="../base/uvm_object-svh.html#uvm_object" class=LClass id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">uvm_object</a></div></div></td></tr>
          <tr><td><div class=CHParent><div class=CHEntry><a href="../base/uvm_transaction-svh.html#uvm_transaction" class=LClass id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">uvm_transaction</a></div></div></td></tr>
          <tr><td><div class=CHParent><div class=CHEntry><a href="uvm_sequence_item-svh.html#uvm_sequence_item" class=LClass id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">uvm_sequence_item</a></div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>uvm_sequence_base</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_sequence_base extends uvm_sequence_item
  </td></tr></table></blockquote></td></tr>

  <!-- index=1 -->

<tr class="SVariable SIndent1 SMarked"><td class=SEntry><a href="#uvm_sequence_base.do_not_randomize" id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">do_not_randomize</a></td><td class=SDescription>If set, prevents the sequence from being randomized before being executed by the `uvm_do*() and `uvm_rand_send*() macros, or as a default sequence.</td></tr>
  <!-- index=2 -->

<tr class="SMethod SIndent1"><td class=SEntry><a href="#uvm_sequence_base.new" id=link7 onMouseOver="ShowTip(event, 'tt7', 'link7')" onMouseOut="HideTip('tt7')">new</a></td><td class=SDescription>The constructor for uvm_sequence_base.</td></tr>
  <!-- index=3 -->

<tr class="SMethod SIndent1 SMarked"><td class=SEntry><a href="#uvm_sequence_base.is_item" id=link8 onMouseOver="ShowTip(event, 'tt8', 'link8')" onMouseOut="HideTip('tt8')">is_item</a></td><td class=SDescription>Returns 1 on items and 0 on sequences. </td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent1"><td class=SEntry><a href="#uvm_sequence_base.get_sequence_state" id=link9 onMouseOver="ShowTip(event, 'tt9', 'link9')" onMouseOut="HideTip('tt9')">get_sequence_state</a></td><td class=SDescription>Returns the sequence state as an enumerated value. </td></tr>
  <!-- index=5 -->

<tr class="SMethod SIndent1 SMarked"><td class=SEntry><a href="#uvm_sequence_base.wait_for_sequence_state" id=link10 onMouseOver="ShowTip(event, 'tt10', 'link10')" onMouseOut="HideTip('tt10')">wait_for_sequence_state</a></td><td class=SDescription>Waits until the sequence reaches one of the given <i>state</i>. </td></tr>
  <!-- index=6 -->

<tr class="SMethod SIndent1"><td class=SEntry><a href="#uvm_sequence_base.get_tr_handle" id=link11 onMouseOver="ShowTip(event, 'tt11', 'link11')" onMouseOut="HideTip('tt11')">get_tr_handle</a></td><td class=SDescription>Returns the integral recording transaction handle for this sequence. </td></tr>
  <!-- index=7 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_sequence_base.Sequence_Execution" >Sequence Execution</a></td><td class=SDescription></td></tr>
  <!-- index=8 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.start" id=link12 onMouseOver="ShowTip(event, 'tt12', 'link12')" onMouseOut="HideTip('tt12')">start</a></td><td class=SDescription>Executes this sequence, returning when the sequence has completed.</td></tr>
  <!-- index=9 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.pre_start" id=link13 onMouseOver="ShowTip(event, 'tt13', 'link13')" onMouseOut="HideTip('tt13')">pre_start</a></td><td class=SDescription>This task is a user-definable callback that is called before the optional execution of <a href="#uvm_sequence_base.pre_body" class=LMethod id=link14 onMouseOver="ShowTip(event, 'tt14', 'link14')" onMouseOut="HideTip('tt14')">pre_body</a>. </td></tr>
  <!-- index=10 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.pre_body" id=link15 onMouseOver="ShowTip(event, 'tt14', 'link15')" onMouseOut="HideTip('tt14')">pre_body</a></td><td class=SDescription>This task is a user-definable callback that is called before the execution of <a href="#uvm_sequence_base.body" class=LMethod id=link16 onMouseOver="ShowTip(event, 'tt15', 'link16')" onMouseOut="HideTip('tt15')">body</a> <i>only</i> when the sequence is started with <a href="#uvm_sequence_base.start" class=LMethod id=link17 onMouseOver="ShowTip(event, 'tt12', 'link17')" onMouseOut="HideTip('tt12')">start</a>. </td></tr>
  <!-- index=11 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.pre_do" id=link18 onMouseOver="ShowTip(event, 'tt16', 'link18')" onMouseOut="HideTip('tt16')">pre_do</a></td><td class=SDescription>This task is a user-definable callback task that is called <i>on the parent sequence</i>, if any sequence has issued a wait_for_grant() call and after the sequencer has selected this sequence, and before the item is randomized.</td></tr>
  <!-- index=12 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.mid_do" id=link19 onMouseOver="ShowTip(event, 'tt17', 'link19')" onMouseOut="HideTip('tt17')">mid_do</a></td><td class=SDescription>This function is a user-definable callback function that is called after the sequence item has been randomized, and just before the item is sent to the driver. </td></tr>
  <!-- index=13 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.body" id=link20 onMouseOver="ShowTip(event, 'tt15', 'link20')" onMouseOut="HideTip('tt15')">body</a></td><td class=SDescription>This is the user-defined task where the main sequence code resides. </td></tr>
  <!-- index=14 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.post_do" id=link21 onMouseOver="ShowTip(event, 'tt18', 'link21')" onMouseOut="HideTip('tt18')">post_do</a></td><td class=SDescription>This function is a user-definable callback function that is called after the driver has indicated that it has completed the item, using either this item_done or put methods. </td></tr>
  <!-- index=15 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.post_body" id=link22 onMouseOver="ShowTip(event, 'tt19', 'link22')" onMouseOut="HideTip('tt19')">post_body</a></td><td class=SDescription>This task is a user-definable callback task that is called after the execution of <a href="#uvm_sequence_base.body" class=LMethod id=link23 onMouseOver="ShowTip(event, 'tt15', 'link23')" onMouseOut="HideTip('tt15')">body</a> <i>only</i> when the sequence is started with <a href="#uvm_sequence_base.start" class=LMethod id=link24 onMouseOver="ShowTip(event, 'tt12', 'link24')" onMouseOut="HideTip('tt12')">start</a>. </td></tr>
  <!-- index=16 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.post_start" id=link25 onMouseOver="ShowTip(event, 'tt20', 'link25')" onMouseOut="HideTip('tt20')">post_start</a></td><td class=SDescription>This task is a user-definable callback that is called after the optional execution of <a href="#uvm_sequence_base.post_body" class=LMethod id=link26 onMouseOver="ShowTip(event, 'tt19', 'link26')" onMouseOut="HideTip('tt19')">post_body</a>. </td></tr>
  <!-- index=17 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_sequence_base.Run-Time_Phasing" >Run-Time Phasing</a></td><td class=SDescription></td></tr>
  <!-- index=18 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.get_starting_phase" id=link27 onMouseOver="ShowTip(event, 'tt21', 'link27')" onMouseOut="HideTip('tt21')">get_starting_phase</a></td><td class=SDescription>Returns the &lsquo;starting phase&rsquo;.</td></tr>
  <!-- index=19 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.set_starting_phase" id=link28 onMouseOver="ShowTip(event, 'tt22', 'link28')" onMouseOut="HideTip('tt22')">set_starting_phase</a></td><td class=SDescription>Sets the &lsquo;starting phase&rsquo;.</td></tr>
  <!-- index=20 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.set_automatic_phase_objection" id=link29 onMouseOver="ShowTip(event, 'tt23', 'link29')" onMouseOut="HideTip('tt23')">set_automatic_phase_objection</a></td><td class=SDescription>Sets the &lsquo;automatically object to starting phase&rsquo; bit.</td></tr>
  <!-- index=21 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.get_automatic_phase_objection" id=link30 onMouseOver="ShowTip(event, 'tt24', 'link30')" onMouseOut="HideTip('tt24')">get_automatic_phase_objection</a></td><td class=SDescription>Returns (and locks) the value of the &lsquo;automatically object to starting phase&rsquo; bit.</td></tr>
  <!-- index=22 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_sequence_base.Sequence_Control" >Sequence Control</a></td><td class=SDescription></td></tr>
  <!-- index=23 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.set_priority" id=link31 onMouseOver="ShowTip(event, 'tt25', 'link31')" onMouseOut="HideTip('tt25')">set_priority</a></td><td class=SDescription>The priority of a sequence may be changed at any point in time. </td></tr>
  <!-- index=24 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.get_priority" id=link32 onMouseOver="ShowTip(event, 'tt26', 'link32')" onMouseOut="HideTip('tt26')">get_priority</a></td><td class=SDescription>This function returns the current priority of the sequence.</td></tr>
  <!-- index=25 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.is_relevant" id=link33 onMouseOver="ShowTip(event, 'tt27', 'link33')" onMouseOut="HideTip('tt27')">is_relevant</a></td><td class=SDescription>The default is_relevant implementation returns 1, indicating that the sequence is always relevant.</td></tr>
  <!-- index=26 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.wait_for_relevant" id=link34 onMouseOver="ShowTip(event, 'tt28', 'link34')" onMouseOut="HideTip('tt28')">wait_for_relevant</a></td><td class=SDescription>This method is called by the sequencer when all available sequences are not relevant. </td></tr>
  <!-- index=27 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.lock" id=link35 onMouseOver="ShowTip(event, 'tt29', 'link35')" onMouseOut="HideTip('tt29')">lock</a></td><td class=SDescription>Requests a lock on the specified sequencer. </td></tr>
  <!-- index=28 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.grab" id=link36 onMouseOver="ShowTip(event, 'tt30', 'link36')" onMouseOut="HideTip('tt30')">grab</a></td><td class=SDescription>Requests a lock on the specified sequencer. </td></tr>
  <!-- index=29 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.unlock" id=link37 onMouseOver="ShowTip(event, 'tt31', 'link37')" onMouseOut="HideTip('tt31')">unlock</a></td><td class=SDescription>Removes any locks or grabs obtained by this sequence on the specified sequencer. </td></tr>
  <!-- index=30 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.ungrab" id=link38 onMouseOver="ShowTip(event, 'tt32', 'link38')" onMouseOut="HideTip('tt32')">ungrab</a></td><td class=SDescription>Removes any locks or grabs obtained by this sequence on the specified sequencer. </td></tr>
  <!-- index=31 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.is_blocked" id=link39 onMouseOver="ShowTip(event, 'tt33', 'link39')" onMouseOut="HideTip('tt33')">is_blocked</a></td><td class=SDescription>Returns a bit indicating whether this sequence is currently prevented from running due to another lock or grab. </td></tr>
  <!-- index=32 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.has_lock" id=link40 onMouseOver="ShowTip(event, 'tt34', 'link40')" onMouseOut="HideTip('tt34')">has_lock</a></td><td class=SDescription>Returns 1 if this sequence has a lock, 0 otherwise.</td></tr>
  <!-- index=33 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.kill" id=link41 onMouseOver="ShowTip(event, 'tt35', 'link41')" onMouseOut="HideTip('tt35')">kill</a></td><td class=SDescription>This function will kill the sequence, and cause all current locks and requests in the sequence&rsquo;s default sequencer to be removed. </td></tr>
  <!-- index=34 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.do_kill" id=link42 onMouseOver="ShowTip(event, 'tt36', 'link42')" onMouseOut="HideTip('tt36')">do_kill</a></td><td class=SDescription>This function is a user hook that is called whenever a sequence is terminated by using either sequence.kill() or sequencer.stop_sequences() (which effectively calls sequence.kill()).</td></tr>
  <!-- index=35 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_sequence_base.Sequence_Item_Execution" >Sequence Item Execution</a></td><td class=SDescription></td></tr>
  <!-- index=36 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.create_item" id=link43 onMouseOver="ShowTip(event, 'tt37', 'link43')" onMouseOut="HideTip('tt37')">create_item</a></td><td class=SDescription>Create_item will create and initialize a sequence_item or sequence using the factory. </td></tr>
  <!-- index=37 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.start_item" id=link44 onMouseOver="ShowTip(event, 'tt38', 'link44')" onMouseOut="HideTip('tt38')">start_item</a></td><td class=SDescription><i>start_item</i> and <a href="#uvm_sequence_base.finish_item" class=LMethod id=link45 onMouseOver="ShowTip(event, 'tt39', 'link45')" onMouseOut="HideTip('tt39')">finish_item</a> together will initiate operation of a sequence item. </td></tr>
  <!-- index=38 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.finish_item" id=link46 onMouseOver="ShowTip(event, 'tt39', 'link46')" onMouseOut="HideTip('tt39')">finish_item</a></td><td class=SDescription>finish_item, together with start_item together will initiate operation of a sequence_item. </td></tr>
  <!-- index=39 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.wait_for_grant" id=link47 onMouseOver="ShowTip(event, 'tt40', 'link47')" onMouseOut="HideTip('tt40')">wait_for_grant</a></td><td class=SDescription>This task issues a request to the current sequencer. </td></tr>
  <!-- index=40 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.send_request" id=link48 onMouseOver="ShowTip(event, 'tt41', 'link48')" onMouseOut="HideTip('tt41')">send_request</a></td><td class=SDescription>The send_request function may only be called after a wait_for_grant call. </td></tr>
  <!-- index=41 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.wait_for_item_done" id=link49 onMouseOver="ShowTip(event, 'tt42', 'link49')" onMouseOut="HideTip('tt42')">wait_for_item_done</a></td><td class=SDescription>A sequence may optionally call wait_for_item_done. </td></tr>
  <!-- index=42 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#uvm_sequence_base.Response_API" >Response API</a></td><td class=SDescription></td></tr>
  <!-- index=43 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.use_response_handler" id=link50 onMouseOver="ShowTip(event, 'tt43', 'link50')" onMouseOut="HideTip('tt43')">use_response_handler</a></td><td class=SDescription>When called with enable set to 1, responses will be sent to the response handler. </td></tr>
  <!-- index=44 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.get_use_response_handler" id=link51 onMouseOver="ShowTip(event, 'tt44', 'link51')" onMouseOut="HideTip('tt44')">get_use_response_handler</a></td><td class=SDescription>Returns the state of the use_response_handler bit.</td></tr>
  <!-- index=45 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.response_handler" id=link52 onMouseOver="ShowTip(event, 'tt45', 'link52')" onMouseOut="HideTip('tt45')">response_handler</a></td><td class=SDescription>When the use_response_handler bit is set to 1, this virtual task is called by the sequencer for each response that arrives for this sequence.</td></tr>
  <!-- index=46 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.set_response_queue_error_report_disabled" id=link53 onMouseOver="ShowTip(event, 'tt46', 'link53')" onMouseOut="HideTip('tt46')">set_response_queue_error_report_disabled</a></td><td class=SDescription>By default, if the response_queue overflows, an error is reported. </td></tr>
  <!-- index=47 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.get_response_queue_error_report_disabled" id=link54 onMouseOver="ShowTip(event, 'tt47', 'link54')" onMouseOut="HideTip('tt47')">get_response_queue_error_report_disabled</a></td><td class=SDescription>When this bit is 0 (default value), error reports are generated when the response queue overflows. </td></tr>
  <!-- index=48 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.set_response_queue_depth" id=link55 onMouseOver="ShowTip(event, 'tt48', 'link55')" onMouseOut="HideTip('tt48')">set_response_queue_depth</a></td><td class=SDescription>The default maximum depth of the response queue is 8. </td></tr>
  <!-- index=49 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#uvm_sequence_base.get_response_queue_depth" id=link56 onMouseOver="ShowTip(event, 'tt49', 'link56')" onMouseOut="HideTip('tt49')">get_response_queue_depth</a></td><td class=SDescription>Returns the current depth setting for the response queue.</td></tr>
  <!-- index=50 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#uvm_sequence_base.clear_response_queue" id=link57 onMouseOver="ShowTip(event, 'tt50', 'link57')" onMouseOut="HideTip('tt50')">clear_response_queue</a></td><td class=SDescription>Empties the response queue for this sequence.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.do_not_randomize" href="../../src/seq/uvm_sequence_base.svh">do_not_randomize</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>bit do_not_randomize
  </td></tr></table></blockquote><div class=CBody><p>If set, prevents the sequence from being randomized before being executed by the `uvm_do*() and `uvm_rand_send*() macros, or as a default sequence.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.new" href="../../src/seq/uvm_sequence_base.svh">new</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function new (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;uvm_sequence&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The constructor for uvm_sequence_base.</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.is_item" href="../../src/seq/uvm_sequence_base.svh">is_item</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function bit is_item()
  </td></tr></table></blockquote><div class=CBody><p>Returns 1 on items and 0 on sequences.&nbsp; As this object is a sequence, <i>is_item</i> will always return 0.</p></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_sequence_state" href="../../src/seq/uvm_sequence_base.svh">get_sequence_state</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function uvm_sequence_state_enum get_sequence_state()
  </td></tr></table></blockquote><div class=CBody><p>Returns the sequence state as an enumerated value.&nbsp; Can use to wait on the sequence reaching or changing from one or more states.</p><blockquote><pre>wait(get_sequence_state() &amp; (UVM_STOPPED|UVM_FINISHED));</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.wait_for_sequence_state" href="../../src/seq/uvm_sequence_base.svh">wait_for_sequence_state</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>task wait_for_sequence_state(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap width=100%>state_mask</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Waits until the sequence reaches one of the given <i>state</i>.&nbsp; If the sequence is already in one of the state, this method returns immediately.</p><blockquote><pre>wait_for_sequence_state(UVM_STOPPED|UVM_FINISHED);</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_tr_handle" href="../../src/seq/uvm_sequence_base.svh">get_tr_handle</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function integer get_tr_handle()
  </td></tr></table></blockquote><div class=CBody><p>Returns the integral recording transaction handle for this sequence.&nbsp; Can be used to associate sub-sequences and sequence items as child transactions when calling <a href="../base/uvm_component-svh.html#uvm_component.begin_child_tr" class=LMethod id=link87 onMouseOver="ShowTip(event, 'tt51', 'link87')" onMouseOut="HideTip('tt51')">uvm_component::begin_child_tr</a>.</p></div></div></div>




 <!--CONTENT index=7 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.Sequence_Execution" href="../../src/seq/uvm_sequence_base.svh">Sequence Execution</a></h3></div></div>




 <!--CONTENT index=8 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.start" href="../../src/seq/uvm_sequence_base.svh">start</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task start (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent_sequence</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>this_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>call_pre_post</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Executes this sequence, returning when the sequence has completed.</p><p>The <i>sequencer</i> argument specifies the sequencer on which to run this sequence.&nbsp; The sequencer must be compatible with the sequence.</p><p>If <i>parent_sequence</i> is <i>null</i>, then this sequence is a root parent, otherwise it is a child of <i>parent_sequence</i>.&nbsp; The <i>parent_sequence</i>&rsquo;s pre_do, mid_do, and post_do methods will be called during the execution of this sequence.</p><p>By default, the <i>priority</i> of a sequence is the priority of its parent sequence.&nbsp; If it is a root sequence, its default priority is 100.&nbsp; A different priority may be specified by <i>this_priority</i>.&nbsp; Higher numbers indicate higher priority.</p><p>If <i>call_pre_post</i> is set to 1 (default), then the <a href="#uvm_sequence_base.pre_body" class=LMethod id=link88 onMouseOver="ShowTip(event, 'tt14', 'link88')" onMouseOut="HideTip('tt14')">pre_body</a> and <a href="#uvm_sequence_base.post_body" class=LMethod id=link89 onMouseOver="ShowTip(event, 'tt19', 'link89')" onMouseOut="HideTip('tt19')">post_body</a> tasks will be called before and after the sequence <a href="#uvm_sequence_base.body" class=LMethod id=link90 onMouseOver="ShowTip(event, 'tt15', 'link90')" onMouseOut="HideTip('tt15')">body</a> is called.</p></div></div></div>




 <!--CONTENT index=9 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.pre_start" href="../../src/seq/uvm_sequence_base.svh">pre_start</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task pre_start()
  </td></tr></table></blockquote><div class=CBody><p>This task is a user-definable callback that is called before the optional execution of <a href="#uvm_sequence_base.pre_body" class=LMethod id=link91 onMouseOver="ShowTip(event, 'tt14', 'link91')" onMouseOut="HideTip('tt14')">pre_body</a>.&nbsp; This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=10 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.pre_body" href="../../src/seq/uvm_sequence_base.svh">pre_body</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task pre_body()
  </td></tr></table></blockquote><div class=CBody><p>This task is a user-definable callback that is called before the execution of <a href="#uvm_sequence_base.body" class=LMethod id=link92 onMouseOver="ShowTip(event, 'tt15', 'link92')" onMouseOut="HideTip('tt15')">body</a> <i>only</i> when the sequence is started with <a href="#uvm_sequence_base.start" class=LMethod id=link93 onMouseOver="ShowTip(event, 'tt12', 'link93')" onMouseOut="HideTip('tt12')">start</a>.&nbsp; If <a href="#uvm_sequence_base.start" class=LMethod id=link94 onMouseOver="ShowTip(event, 'tt12', 'link94')" onMouseOut="HideTip('tt12')">start</a> is called with <i>call_pre_post</i> set to 0, <i>pre_body</i> is not called.&nbsp; This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=11 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.pre_do" href="../../src/seq/uvm_sequence_base.svh">pre_do</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task pre_do(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_item</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>This task is a user-definable callback task that is called <i>on the parent sequence</i>, if any sequence has issued a wait_for_grant() call and after the sequencer has selected this sequence, and before the item is randomized.</p><p>Although pre_do is a task, consuming simulation cycles may result in unexpected behavior on the driver.</p><p>This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=12 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.mid_do" href="../../src/seq/uvm_sequence_base.svh">mid_do</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void mid_do(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>this_item</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>This function is a user-definable callback function that is called after the sequence item has been randomized, and just before the item is sent to the driver.&nbsp;  This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=13 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.body" href="../../src/seq/uvm_sequence_base.svh">body</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task body()
  </td></tr></table></blockquote><div class=CBody><p>This is the user-defined task where the main sequence code resides.&nbsp; This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=14 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.post_do" href="../../src/seq/uvm_sequence_base.svh">post_do</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void post_do(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>this_item</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>This function is a user-definable callback function that is called after the driver has indicated that it has completed the item, using either this item_done or put methods.&nbsp; This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=15 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.post_body" href="../../src/seq/uvm_sequence_base.svh">post_body</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task post_body()
  </td></tr></table></blockquote><div class=CBody><p>This task is a user-definable callback task that is called after the execution of <a href="#uvm_sequence_base.body" class=LMethod id=link95 onMouseOver="ShowTip(event, 'tt15', 'link95')" onMouseOut="HideTip('tt15')">body</a> <i>only</i> when the sequence is started with <a href="#uvm_sequence_base.start" class=LMethod id=link96 onMouseOver="ShowTip(event, 'tt12', 'link96')" onMouseOut="HideTip('tt12')">start</a>.&nbsp; If <a href="#uvm_sequence_base.start" class=LMethod id=link97 onMouseOver="ShowTip(event, 'tt12', 'link97')" onMouseOut="HideTip('tt12')">start</a> is called with <i>call_pre_post</i> set to 0, <i>post_body</i> is not called.&nbsp; This task is a user-definable callback task that is called after the execution of the body, unless the sequence is started with call_pre_post=0.&nbsp; This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=16 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.post_start" href="../../src/seq/uvm_sequence_base.svh">post_start</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task post_start()
  </td></tr></table></blockquote><div class=CBody><p>This task is a user-definable callback that is called after the optional execution of <a href="#uvm_sequence_base.post_body" class=LMethod id=link98 onMouseOver="ShowTip(event, 'tt19', 'link98')" onMouseOut="HideTip('tt19')">post_body</a>.&nbsp; This method should not be called directly by the user.</p></div></div></div>




 <!--CONTENT index=17 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.Run-Time_Phasing" href="../../src/seq/uvm_sequence_base.svh">Run-Time Phasing</a></h3></div></div>




 <!--CONTENT index=18 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_starting_phase" href="../../src/seq/uvm_sequence_base.svh">get_starting_phase</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function uvm_phase get_starting_phase()
  </td></tr></table></blockquote><div class=CBody><p>Returns the &lsquo;starting phase&rsquo;.</p><p>If non-<i>null</i>, the starting phase specifies the phase in which this sequence was started.&nbsp;  The starting phase is set automatically when this sequence is started as the default sequence on a sequencer.&nbsp; See <a href="uvm_sequencer_base-svh.html#uvm_sequencer_base.start_phase_sequence" class=LMethod id=link99 onMouseOver="ShowTip(event, 'tt52', 'link99')" onMouseOut="HideTip('tt52')">uvm_sequencer_base::start_phase_sequence</a> for more information.</p><p>Internally, the <a href="#uvm_sequence_base" class=LClass id=link100 onMouseOver="ShowTip(event, 'tt5', 'link100')" onMouseOut="HideTip('tt5')">uvm_sequence_base</a> uses an <a href="../dap/uvm_get_to_lock_dap-svh.html#uvm_get_to_lock_dap" class=LClass id=link101 onMouseOver="ShowTip(event, 'tt53', 'link101')" onMouseOut="HideTip('tt53')">uvm_get_to_lock_dap</a> to protect the starting phase value from being modified after the reference has been read.&nbsp;  Once the sequence has ended its execution (either via natural termination, or being killed), then the starting phase value can be modified again.</p></div></div></div>




 <!--CONTENT index=19 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.set_starting_phase" href="../../src/seq/uvm_sequence_base.svh">set_starting_phase</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_starting_phase(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_phase&nbsp;</td>
      <td class=PParameter nowrap width=100%>phase</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Sets the &lsquo;starting phase&rsquo;.</p><p>Internally, the <a href="#uvm_sequence_base" class=LClass id=link102 onMouseOver="ShowTip(event, 'tt5', 'link102')" onMouseOut="HideTip('tt5')">uvm_sequence_base</a> uses a <a href="../dap/uvm_get_to_lock_dap-svh.html#uvm_get_to_lock_dap" class=LClass id=link103 onMouseOver="ShowTip(event, 'tt53', 'link103')" onMouseOut="HideTip('tt53')">uvm_get_to_lock_dap</a> to protect the starting phase value from being modified after the reference has been read.&nbsp;  Once the sequence has ended its execution (either via natural termination, or being killed), then the starting phase value can be modified again.</p></div></div></div>




 <!--CONTENT index=20 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.set_automatic_phase_objection" href="../../src/seq/uvm_sequence_base.svh">set_automatic_phase_objection</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_automatic_phase_objection(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Sets the &lsquo;automatically object to starting phase&rsquo; bit.</p><p>The most common interaction with the starting phase within a sequence is to simply <i>raise</i> the phase&rsquo;s objection prior to executing the sequence, and <i>drop</i> the objection after ending the sequence (either naturally, or via a call to <a href="#uvm_sequence_base.kill" class=LMethod id=link104 onMouseOver="ShowTip(event, 'tt35', 'link104')" onMouseOut="HideTip('tt35')">kill</a>).&nbsp; In order to simplify this interaction for the user, the UVM provides the ability to perform this functionality automatically.</p><h4 class=CHeading>For example</h4><blockquote><pre>function my_sequence::new(string name=&quot;unnamed&quot;);
  super.new(name);
  set_automatic_phase_objection(1);
endfunction : new</pre></blockquote><p>From a timeline point of view, the automatic phase objection looks like:</p><blockquote><pre>start() is executed
  --! Objection is raised !--
  pre_start() is executed
  pre_body() is optionally executed
  body() is executed
  post_body() is optionally executed
  post_start() is executed
  --! Objection is dropped !--
start() unblocks</pre></blockquote><p>This functionality can also be enabled in sequences which were not written with UVM Run-Time Phasing in mind:</p><blockquote><pre>my_legacy_seq_type seq = new(&quot;seq&quot;);
seq.set_automatic_phase_objection(1);
seq.start(my_sequencer);</pre></blockquote><p>Internally, the <a href="#uvm_sequence_base" class=LClass id=link105 onMouseOver="ShowTip(event, 'tt5', 'link105')" onMouseOut="HideTip('tt5')">uvm_sequence_base</a> uses a <a href="../dap/uvm_get_to_lock_dap-svh.html#uvm_get_to_lock_dap" class=LClass id=link106 onMouseOver="ShowTip(event, 'tt53', 'link106')" onMouseOut="HideTip('tt53')">uvm_get_to_lock_dap</a> to protect the <i>automatic_phase_objection</i> value from being modified after the reference has been read.&nbsp;  Once the sequence has ended its execution (either via natural termination, or being killed), then the <i>automatic_phase_objection</i> value can be modified again.</p><p>NEVER set the automatic phase objection bit to 1 if your sequence runs with a forever loop inside of the body, as the objection will never get dropped!</p></div></div></div>




 <!--CONTENT index=21 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_automatic_phase_objection" href="../../src/seq/uvm_sequence_base.svh">get_automatic_phase_objection</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit get_automatic_phase_objection()
  </td></tr></table></blockquote><div class=CBody><p>Returns (and locks) the value of the &lsquo;automatically object to starting phase&rsquo; bit.</p><p>If 1, then the sequence will automatically raise an objection to the starting phase (if the starting phase is not <i>null</i>) immediately prior to <a href="#uvm_sequence_base.pre_start" class=LMethod id=link107 onMouseOver="ShowTip(event, 'tt13', 'link107')" onMouseOut="HideTip('tt13')">pre_start</a> being called.&nbsp;  The objection will be dropped after <a href="#uvm_sequence_base.post_start" class=LMethod id=link108 onMouseOver="ShowTip(event, 'tt20', 'link108')" onMouseOut="HideTip('tt20')">post_start</a> has executed, or <a href="#uvm_sequence_base.kill" class=LMethod id=link109 onMouseOver="ShowTip(event, 'tt35', 'link109')" onMouseOut="HideTip('tt35')">kill</a> has been called.</p></div></div></div>




 <!--CONTENT index=22 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.Sequence_Control" href="../../src/seq/uvm_sequence_base.svh">Sequence Control</a></h3></div></div>




 <!--CONTENT index=23 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.set_priority" href="../../src/seq/uvm_sequence_base.svh">set_priority</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_priority (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The priority of a sequence may be changed at any point in time.&nbsp;  When the priority of a sequence is changed, the new priority will be used by the sequencer the next time that it arbitrates between sequences.</p><p>The default priority value for a sequence is 100.&nbsp;  Higher values result in higher priorities.</p></div></div></div>




 <!--CONTENT index=24 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_priority" href="../../src/seq/uvm_sequence_base.svh">get_priority</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int get_priority()
  </td></tr></table></blockquote><div class=CBody><p>This function returns the current priority of the sequence.</p></div></div></div>




 <!--CONTENT index=25 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.is_relevant" href="../../src/seq/uvm_sequence_base.svh">is_relevant</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function bit is_relevant()
  </td></tr></table></blockquote><div class=CBody><p>The default is_relevant implementation returns 1, indicating that the sequence is always relevant.</p><p>Users may choose to override with their own virtual function to indicate to the sequencer that the sequence is not currently relevant after a request has been made.</p><p>When the sequencer arbitrates, it will call is_relevant on each requesting, unblocked sequence to see if it is relevant.&nbsp; If a 0 is returned, then the sequence will not be chosen.</p><p>If all requesting sequences are not relevant, then the sequencer will call wait_for_relevant on all sequences and re-arbitrate upon its return.</p><p>Any sequence that implements is_relevant must also implement wait_for_relevant so that the sequencer has a way to wait for a sequence to become relevant.</p></div></div></div>




 <!--CONTENT index=26 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.wait_for_relevant" href="../../src/seq/uvm_sequence_base.svh">wait_for_relevant</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task wait_for_relevant()
  </td></tr></table></blockquote><div class=CBody><p>This method is called by the sequencer when all available sequences are not relevant.&nbsp;  When wait_for_relevant returns the sequencer attempt to re-arbitrate.</p><p>Returning from this call does not guarantee a sequence is relevant, although that would be the ideal.&nbsp; The method provide some delay to prevent an infinite loop.</p><p>If a sequence defines is_relevant so that it is not always relevant (by default, a sequence is always relevant), then the sequence must also supply a wait_for_relevant method.</p></div></div></div>




 <!--CONTENT index=27 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.lock" href="../../src/seq/uvm_sequence_base.svh">lock</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>task lock(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Requests a lock on the specified sequencer.&nbsp; If sequencer is <i>null</i>, the lock will be requested on the current default sequencer.</p><p>A lock request will be arbitrated the same as any other request.&nbsp;  A lock is granted after all earlier requests are completed and no other locks or grabs are blocking this sequence.</p><p>The lock call will return when the lock has been granted.</p></div></div></div>




 <!--CONTENT index=28 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.grab" href="../../src/seq/uvm_sequence_base.svh">grab</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>task grab(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Requests a lock on the specified sequencer.&nbsp;  If no argument is supplied, the lock will be requested on the current default sequencer.</p><p>A grab request is put in front of the arbitration queue.&nbsp; It will be arbitrated before any other requests.&nbsp; A grab is granted when no other grabs or locks are blocking this sequence.</p><p>The grab call will return when the grab has been granted.</p></div></div></div>




 <!--CONTENT index=29 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.unlock" href="../../src/seq/uvm_sequence_base.svh">unlock</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void unlock(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Removes any locks or grabs obtained by this sequence on the specified sequencer.&nbsp; If sequencer is <i>null</i>, then the unlock will be done on the current default sequencer.</p></div></div></div>




 <!--CONTENT index=30 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.ungrab" href="../../src/seq/uvm_sequence_base.svh">ungrab</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void ungrab(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Removes any locks or grabs obtained by this sequence on the specified sequencer.&nbsp; If sequencer is <i>null</i>, then the unlock will be done on the current default sequencer.</p></div></div></div>




 <!--CONTENT index=31 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.is_blocked" href="../../src/seq/uvm_sequence_base.svh">is_blocked</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit is_blocked()
  </td></tr></table></blockquote><div class=CBody><p>Returns a bit indicating whether this sequence is currently prevented from running due to another lock or grab.&nbsp; A 1 is returned if the sequence is currently blocked.&nbsp; A 0 is returned if no lock or grab prevents this sequence from executing.&nbsp; Note that even if a sequence is not blocked, it is possible for another sequence to issue a lock or grab before this sequence can issue a request.</p></div></div></div>




 <!--CONTENT index=32 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.has_lock" href="../../src/seq/uvm_sequence_base.svh">has_lock</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit has_lock()
  </td></tr></table></blockquote><div class=CBody><p>Returns 1 if this sequence has a lock, 0 otherwise.</p><p>Note that even if this sequence has a lock, a child sequence may also have a lock, in which case the sequence is still blocked from issuing operations on the sequencer.</p></div></div></div>




 <!--CONTENT index=33 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.kill" href="../../src/seq/uvm_sequence_base.svh">kill</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function void kill()
  </td></tr></table></blockquote><div class=CBody><p>This function will kill the sequence, and cause all current locks and requests in the sequence&rsquo;s default sequencer to be removed.&nbsp; The sequence state will change to UVM_STOPPED, and the post_body() and post_start() callback methods will not be executed.</p><p>If a sequence has issued locks, grabs, or requests on sequencers other than the default sequencer, then care must be taken to unregister the sequence with the other sequencer(s) using the sequencer unregister_sequence() method.</p></div></div></div>




 <!--CONTENT index=34 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.do_kill" href="../../src/seq/uvm_sequence_base.svh">do_kill</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function void do_kill()
  </td></tr></table></blockquote><div class=CBody><p>This function is a user hook that is called whenever a sequence is terminated by using either sequence.kill() or sequencer.stop_sequences() (which effectively calls sequence.kill()).</p></div></div></div>




 <!--CONTENT index=35 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.Sequence_Item_Execution" href="../../src/seq/uvm_sequence_base.svh">Sequence Item Execution</a></h3></div></div>




 <!--CONTENT index=36 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.create_item" href="../../src/seq/uvm_sequence_base.svh">create_item</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>protected function uvm_sequence_item create_item(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object_wrapper&nbsp;</td>
      <td class=PParameter nowrap width=100%>type_var,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap width=100%>l_sequencer,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Create_item will create and initialize a sequence_item or sequence using the factory.&nbsp;  The sequence_item or sequence will be initialized to communicate with the specified sequencer.</p></div></div></div>




 <!--CONTENT index=37 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.start_item" href="../../src/seq/uvm_sequence_base.svh">start_item</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task start_item (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap>item,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>set_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p><i>start_item</i> and <a href="#uvm_sequence_base.finish_item" class=LMethod id=link110 onMouseOver="ShowTip(event, 'tt39', 'link110')" onMouseOut="HideTip('tt39')">finish_item</a> together will initiate operation of a sequence item.&nbsp;  If the item has not already been initialized using create_item, then it will be initialized here to use the default sequencer specified by m_sequencer.&nbsp;  Randomization may be done between start_item and finish_item to ensure late generation</p></div></div></div>




 <!--CONTENT index=38 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.finish_item" href="../../src/seq/uvm_sequence_base.svh">finish_item</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task finish_item (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap>item,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>set_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>finish_item, together with start_item together will initiate operation of a sequence_item.&nbsp;  Finish_item must be called after start_item with no delays or delta-cycles.&nbsp;  Randomization, or other functions may be called between the start_item and finish_item calls.</p></div></div></div>




 <!--CONTENT index=39 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.wait_for_grant" href="../../src/seq/uvm_sequence_base.svh">wait_for_grant</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task wait_for_grant(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>item_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>lock_request</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>This task issues a request to the current sequencer.&nbsp;  If item_priority is not specified, then the current sequence priority will be used by the arbiter.&nbsp; If a lock_request is made, then the sequencer will issue a lock immediately before granting the sequence.&nbsp;  (Note that the lock may be granted without the sequence being granted if is_relevant is not asserted).</p><p>When this method returns, the sequencer has granted the sequence, and the sequence must call send_request without inserting any simulation delay other than delta cycles.&nbsp;  The driver is currently waiting for the next item to be sent via the send_request call.</p></div></div></div>




 <!--CONTENT index=40 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.send_request" href="../../src/seq/uvm_sequence_base.svh">send_request</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void send_request(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap>request,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>rerandomize</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The send_request function may only be called after a wait_for_grant call.&nbsp; This call will send the request item to the sequencer, which will forward it to the driver.&nbsp; If the rerandomize bit is set, the item will be randomized before being sent to the driver.</p></div></div></div>




 <!--CONTENT index=41 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.wait_for_item_done" href="../../src/seq/uvm_sequence_base.svh">wait_for_item_done</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task wait_for_item_done(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>transaction_id</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>A sequence may optionally call wait_for_item_done.&nbsp;  This task will block until the driver calls item_done or put.&nbsp;  If no transaction_id parameter is specified, then the call will return the next time that the driver calls item_done or put.&nbsp;  If a specific transaction_id is specified, then the call will return when the driver indicates completion of that specific item.</p><p>Note that if a specific transaction_id has been specified, and the driver has already issued an item_done or put for that transaction, then the call will hang, having missed the earlier notification.</p></div></div></div>




 <!--CONTENT index=42 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.Response_API" href="../../src/seq/uvm_sequence_base.svh">Response API</a></h3></div></div>




 <!--CONTENT index=43 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.use_response_handler" href="../../src/seq/uvm_sequence_base.svh">use_response_handler</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void use_response_handler(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>enable</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>When called with enable set to 1, responses will be sent to the response handler.&nbsp; Otherwise, responses must be retrieved using get_response.</p><p>By default, responses from the driver are retrieved in the sequence by calling get_response.</p><p>An alternative method is for the sequencer to call the response_handler function with each response.</p></div></div></div>




 <!--CONTENT index=44 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_use_response_handler" href="../../src/seq/uvm_sequence_base.svh">get_use_response_handler</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit get_use_response_handler()
  </td></tr></table></blockquote><div class=CBody><p>Returns the state of the use_response_handler bit.</p></div></div></div>




 <!--CONTENT index=45 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.response_handler" href="../../src/seq/uvm_sequence_base.svh">response_handler</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void response_handler(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>response</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>When the use_response_handler bit is set to 1, this virtual task is called by the sequencer for each response that arrives for this sequence.</p></div></div></div>




 <!--CONTENT index=46 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.set_response_queue_error_report_disabled" href="../../src/seq/uvm_sequence_base.svh">set_response_queue_error_report_disabled</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_response_queue_error_report_disabled(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>By default, if the response_queue overflows, an error is reported.&nbsp; The response_queue will overflow if more responses are sent to this sequence from the driver than get_response calls are made.&nbsp; Setting value to 0 disables these errors, while setting it to 1 enables them.</p></div></div></div>




 <!--CONTENT index=47 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_response_queue_error_report_disabled" href="../../src/seq/uvm_sequence_base.svh">get_response_queue_error_report_disabled</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit get_response_queue_error_report_disabled()
  </td></tr></table></blockquote><div class=CBody><p>When this bit is 0 (default value), error reports are generated when the response queue overflows.&nbsp; When this bit is 1, no such error reports are generated.</p></div></div></div>




 <!--CONTENT index=48 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.set_response_queue_depth" href="../../src/seq/uvm_sequence_base.svh">set_response_queue_depth</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_response_queue_depth(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>The default maximum depth of the response queue is 8.&nbsp; These method is used to examine or change the maximum depth of the response queue.</p><p>Setting the response_queue_depth to -1 indicates an arbitrarily deep response queue.&nbsp;  No checking is done.</p></div></div></div>




 <!--CONTENT index=49 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.get_response_queue_depth" href="../../src/seq/uvm_sequence_base.svh">get_response_queue_depth</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int get_response_queue_depth()
  </td></tr></table></blockquote><div class=CBody><p>Returns the current depth setting for the response queue.</p></div></div></div>




 <!--CONTENT index=50 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="uvm_sequence_base.clear_response_queue" href="../../src/seq/uvm_sequence_base.svh">clear_response_queue</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function void clear_response_queue()
  </td></tr></table></blockquote><div class=CBody><p>Empties the response queue for this sequence.</p></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_void
  </td></tr></table></blockquote>The <i>uvm_void</i> class is the base class for all UVM classes. </div></div><div class=CToolTip id="tt2"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_object extends uvm_void
  </td></tr></table></blockquote>The uvm_object class is the base class for all UVM data and hierarchical classes. </div></div><div class=CToolTip id="tt3"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual class uvm_transaction extends uvm_object
  </td></tr></table></blockquote>The uvm_transaction class is the root base class for UVM transactions. </div></div><div class=CToolTip id="tt4"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_sequence_item extends uvm_transaction
  </td></tr></table></blockquote>The base class for user-defined sequence items and also the base class for the uvm_sequence class. </div></div><div class=CToolTip id="tt5"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class uvm_sequence_base extends uvm_sequence_item
  </td></tr></table></blockquote>The uvm_sequence_base class provides the interfaces needed to create streams of sequence items and/or other sequences.</div></div><div class=CToolTip id="tt6"><div class=CVariable>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>bit do_not_randomize
  </td></tr></table></blockquote>If set, prevents the sequence from being randomized before being executed by the `uvm_do*() and `uvm_rand_send*() macros, or as a default sequence.</div></div><div class=CToolTip id="tt7"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function new (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> &quot;uvm_sequence&quot;</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The constructor for uvm_sequence_base.</div></div><div class=CToolTip id="tt8"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function bit is_item()
  </td></tr></table></blockquote>Returns 1 on items and 0 on sequences. </div></div><div class=CToolTip id="tt9"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function uvm_sequence_state_enum get_sequence_state()
  </td></tr></table></blockquote>Returns the sequence state as an enumerated value. </div></div><div class=CToolTip id="tt10"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=4>task wait_for_sequence_state(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PTypePrefix nowrap>int&nbsp;</td>
      <td class=PType nowrap>unsigned&nbsp;</td>
      <td class=PParameter nowrap width=100%>state_mask</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=4>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Waits until the sequence reaches one of the given <i>state</i>. </div></div><div class=CToolTip id="tt11"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function integer get_tr_handle()
  </td></tr></table></blockquote>Returns the integral recording transaction handle for this sequence. </div></div><div class=CToolTip id="tt12"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task start (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_base&nbsp;</td>
      <td class=PParameter nowrap>parent_sequence</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>this_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>call_pre_post</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Executes this sequence, returning when the sequence has completed.</div></div><div class=CToolTip id="tt13"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task pre_start()
  </td></tr></table></blockquote>This task is a user-definable callback that is called before the optional execution of pre_body. </div></div><div class=CToolTip id="tt14"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task pre_body()
  </td></tr></table></blockquote>This task is a user-definable callback that is called before the execution of body <i>only</i> when the sequence is started with start. </div></div><div class=CToolTip id="tt15"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task body()
  </td></tr></table></blockquote>This is the user-defined task where the main sequence code resides. </div></div><div class=CToolTip id="tt16"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual task pre_do(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>is_item</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
This task is a user-definable callback task that is called <i>on the parent sequence</i>, if any sequence has issued a wait_for_grant() call and after the sequencer has selected this sequence, and before the item is randomized.</div></div><div class=CToolTip id="tt17"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void mid_do(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>this_item</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
This function is a user-definable callback function that is called after the sequence item has been randomized, and just before the item is sent to the driver. </div></div><div class=CToolTip id="tt18"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void post_do(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>this_item</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
This function is a user-definable callback function that is called after the driver has indicated that it has completed the item, using either this item_done or put methods. </div></div><div class=CToolTip id="tt19"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task post_body()
  </td></tr></table></blockquote>This task is a user-definable callback task that is called after the execution of body <i>only</i> when the sequence is started with start. </div></div><div class=CToolTip id="tt20"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task post_start()
  </td></tr></table></blockquote>This task is a user-definable callback that is called after the optional execution of post_body. </div></div><div class=CToolTip id="tt21"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function uvm_phase get_starting_phase()
  </td></tr></table></blockquote>Returns the &lsquo;starting phase&rsquo;.</div></div><div class=CToolTip id="tt22"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_starting_phase(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_phase&nbsp;</td>
      <td class=PParameter nowrap width=100%>phase</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Sets the &lsquo;starting phase&rsquo;.</div></div><div class=CToolTip id="tt23"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_automatic_phase_objection(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Sets the &lsquo;automatically object to starting phase&rsquo; bit.</div></div><div class=CToolTip id="tt24"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit get_automatic_phase_objection()
  </td></tr></table></blockquote>Returns (and locks) the value of the &lsquo;automatically object to starting phase&rsquo; bit.</div></div><div class=CToolTip id="tt25"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_priority (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The priority of a sequence may be changed at any point in time. </div></div><div class=CToolTip id="tt26"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int get_priority()
  </td></tr></table></blockquote>This function returns the current priority of the sequence.</div></div><div class=CToolTip id="tt27"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function bit is_relevant()
  </td></tr></table></blockquote>The default is_relevant implementation returns 1, indicating that the sequence is always relevant.</div></div><div class=CToolTip id="tt28"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual task wait_for_relevant()
  </td></tr></table></blockquote>This method is called by the sequencer when all available sequences are not relevant. </div></div><div class=CToolTip id="tt29"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>task lock(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Requests a lock on the specified sequencer. </div></div><div class=CToolTip id="tt30"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>task grab(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Requests a lock on the specified sequencer. </div></div><div class=CToolTip id="tt31"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void unlock(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Removes any locks or grabs obtained by this sequence on the specified sequencer. </div></div><div class=CToolTip id="tt32"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function void ungrab(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Removes any locks or grabs obtained by this sequence on the specified sequencer. </div></div><div class=CToolTip id="tt33"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit is_blocked()
  </td></tr></table></blockquote>Returns a bit indicating whether this sequence is currently prevented from running due to another lock or grab. </div></div><div class=CToolTip id="tt34"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit has_lock()
  </td></tr></table></blockquote>Returns 1 if this sequence has a lock, 0 otherwise.</div></div><div class=CToolTip id="tt35"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function void kill()
  </td></tr></table></blockquote>This function will kill the sequence, and cause all current locks and requests in the sequence&rsquo;s default sequencer to be removed. </div></div><div class=CToolTip id="tt36"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function void do_kill()
  </td></tr></table></blockquote>This function is a user hook that is called whenever a sequence is terminated by using either sequence.kill() or sequencer.stop_sequences() (which effectively calls sequence.kill()).</div></div><div class=CToolTip id="tt37"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>protected function uvm_sequence_item create_item(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_object_wrapper&nbsp;</td>
      <td class=PParameter nowrap width=100%>type_var,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap width=100%>l_sequencer,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap width=100%>name</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Create_item will create and initialize a sequence_item or sequence using the factory. </div></div><div class=CToolTip id="tt38"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task start_item (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap>item,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>set_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequencer_base&nbsp;</td>
      <td class=PParameter nowrap>sequencer</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<i>start_item</i> and finish_item together will initiate operation of a sequence item. </div></div><div class=CToolTip id="tt39"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task finish_item (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap>item,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>set_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
finish_item, together with start_item together will initiate operation of a sequence_item. </div></div><div class=CToolTip id="tt40"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task wait_for_grant(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>item_priority</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>lock_request</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
This task issues a request to the current sequencer. </div></div><div class=CToolTip id="tt41"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual function void send_request(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap>request,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap>rerandomize</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> 0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The send_request function may only be called after a wait_for_grant call. </div></div><div class=CToolTip id="tt42"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>virtual task wait_for_item_done(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap>transaction_id</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%> -1</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
A sequence may optionally call wait_for_item_done. </div></div><div class=CToolTip id="tt43"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void use_response_handler(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>enable</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
When called with enable set to 1, responses will be sent to the response handler. </div></div><div class=CToolTip id="tt44"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit get_use_response_handler()
  </td></tr></table></blockquote>Returns the state of the use_response_handler bit.</div></div><div class=CToolTip id="tt45"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void response_handler(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_sequence_item&nbsp;</td>
      <td class=PParameter nowrap width=100%>response</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
When the use_response_handler bit is set to 1, this virtual task is called by the sequencer for each response that arrives for this sequence.</div></div><div class=CToolTip id="tt46"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_response_queue_error_report_disabled(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>bit&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
By default, if the response_queue overflows, an error is reported. </div></div><div class=CToolTip id="tt47"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function bit get_response_queue_error_report_disabled()
  </td></tr></table></blockquote>When this bit is 0 (default value), error reports are generated when the response queue overflows. </div></div><div class=CToolTip id="tt48"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>function void set_response_queue_depth(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>int&nbsp;</td>
      <td class=PParameter nowrap width=100%>value</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
The default maximum depth of the response queue is 8. </div></div><div class=CToolTip id="tt49"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>function int get_response_queue_depth()
  </td></tr></table></blockquote>Returns the current depth setting for the response queue.</div></div><div class=CToolTip id="tt50"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>virtual function void clear_response_queue()
  </td></tr></table></blockquote>Empties the response queue for this sequence.</div></div><div class=CToolTip id="tt51"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>function integer begin_child_tr (</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_transaction&nbsp;</td>
      <td class=PParameter nowrap>tr,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>integer&nbsp;</td>
      <td class=PParameter nowrap>parent_handle</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>0,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>stream_name</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;main&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>label</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>desc</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>&quot;&quot;,</td>
      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>time&nbsp;</td>
      <td class=PParameter nowrap>begin_time</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>0</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>)</td></tr>
      </table></td></tr>
    </table></blockquote>
This function marks the start of a child transaction, <i>tr</i>, by this component. </div></div><div class=CToolTip id="tt52"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=3>virtual function void start_phase_sequence(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>uvm_phase&nbsp;</td>
      <td class=PParameter nowrap width=100%>phase</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=3>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Start the default sequence for this phase, if any. </div></div><div class=CToolTip id="tt53"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters colspan=5>class uvm_get_to_lock_dap#(</td>      </tr><tr><td>&nbsp;&nbsp;&nbsp;</td>      <td class=PType nowrap>type&nbsp;</td>
      <td class=PParameter nowrap>T</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>int</td>
    </tr>
    <tr>
      <td class=PAfterParameters colspan=5>) extends uvm_set_get_dap_base#(T)</td></tr>
      </table></td></tr>
    </table></blockquote>
Provides a &lsquo;Get-To-Lock&rsquo; Data Access Policy.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>