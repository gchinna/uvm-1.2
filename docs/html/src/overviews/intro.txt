
Title: UVM 1.2 Class Reference

The UVM Class Library provides the building blocks needed to quickly develop
well-constructed and reusable verification components and test environments in
SystemVerilog.

This UVM Class Reference provides detailed reference information
for each user-visible class in the UVM library. For additional
information on using UVM, see the UVM User's Guide located in the top
level directory within the UVM kit.

We divide the UVM classes and utilities into categories pertaining to their
role or function. A more detailed overview of each category-- and the classes
comprising them-- can be found in the menu at left.

Globals - This category defines a small list of types, variables, functions,
and tasks defined in the ~uvm_pkg~ scope.  These items are accessible from
any scope that imports the ~uvm_pkg~. See <Types and Enumerations> and
<Globals> for details.

Base - This basic building blocks for all environments are components,
which do the actual work, transactions, which convey information between
components, and ports, which provide the interfaces used to convey
transactions.  The UVM's core ~base~ classes provide these building blocks.
See <Core Base Classes> for more information.

Reporting - The ~reporting~ classes provide a facility for issuing reports 
(messages) with consistent formatting and configurable side effects, such as
logging to a file or exiting simulation.  Users can also filter out reports
based on their verbosity , unique ID, or severity. See <Reporting Classes> for
more information.

Factory - As the name implies, the UVM factory is used to manufacture (create)
UVM objects and components.  Users can configure the factory to produce an
object of a given type on a global or instance basis. Use of the factory
allows dynamically configurable component hierarchies and object substitutions
without having to modify their code and without breaking encapsulation.
See <Factory Classes> for details.

Phasing - This sections describes the phasing capability providing by UVM.
The details can be found in <Phasing Overview>.

Configuration and Resources - The <Configuration and Resource Classes> are
a set of classes which provide a configuration database. The configuration
database is used to store and retrieve both configuration time and
run time properties.

Synchronization - The UVM provides event and barrier synchronization classes
for process synchronization. See <Synchronization Classes> for more information.

Containers - The <Container Classes> are type parameterized data structures 
which provide queue and pool services. The class based queue and pool types
allow for efficient sharing of the data structures compared with their
SystemVerilog built-in counterparts.

Policies - Each of UVM's policy classes performs a specific task for
<uvm_object>-based objects: printing, comparing, recording, packing, and unpacking.
They are implemented separately from ~uvm_object~ so that users can plug in
different ways to print, compare, etc. without modifying the object class being
operated on. The user can simply apply a different printer or compare "policy"
to change how an object is printed or compared.  See <Policy Classes> for more
information.

TLM - The UVM TLM library defines several abstract, transaction-level interfaces
and the ports and exports that facilitate their use.  Each TLM interface
consists of one or more methods used to transport data, typically whole
transactions (objects) at a time.  Component designs that use TLM ports and
exports to communicate are inherently more reusable, interoperable, and modular.
See <TLM Interfaces> for details.

Components - Components form the foundation of the UVM. They encapsulate
behavior of drivers, scoreboards, and other objects in a testbench.
The UVM library provides a set of predefined component types, all derived
directly or indirectly from <uvm_component>.  See <Predefined Component Classes>
for more information.

Sequencers - The sequencer serves as an arbiter for controlling transaction
flow from multiple stimulus generators. More specifically, the sequencer
controls the flow of <uvm_sequence_item>-based transactions generated by one
or more <uvm_sequence #(REQ,RSP)>-based sequences.  
See <Sequencer Classes> for more information.

Sequences - Sequences encapsulate user-defined procedures that generate
multiple <uvm_sequence_item>-based transactions. Such sequences can be reused,
extended, randomized, and combined sequentially and hierarchically in
interesting ways to produce realistic stimulus to your DUT.
See <Sequence Classes> for more information.

Macros - The UVM provides several macros to help increase user productivity.
See the set of macro categories in the main menu for a complete list of macros
for Reporting, Components, Objects, Sequences, Callbacks, TLM and Registers.

Register Layer - The Register abstraction classes, when properly extended,
abstract the read/write operations to registers and memories
in a design-under-verification.
See <Register Layer> for more information.

Command Line Processor - The command line processor provides a general
interface to the command line arguments that were provided for the given
simulation.  The capabilities are detailed in the <uvm_cmdline_processor>
section.

